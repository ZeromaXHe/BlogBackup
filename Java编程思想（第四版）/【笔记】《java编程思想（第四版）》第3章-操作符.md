# 第3章 操作符

在最底层，Java中的数据是通过使用操作符来操作的。

## 3.1 更简单的打印语句

在第6章中将介绍静态导入（static import）这个在Java SE5中新增加的概念，并将创建一个小类库来简化打印语句的编写。

## 3.2 使用Java操作符

操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但效果是相同的。加号和一元的正好（+）、减号和一元的负号（-）、乘号（*）、除号（/）以及赋值（=）的用法与其他编程语言类似。

副作用：一些操作符可能会改变操作数自身的值

几乎所有的操作符都只能操作“基本类型”。例外的操作符是“=”、“==”和“！=”，这些操作符能操作所有的对象（这也是对象易令人糊涂的地方）。除此之外，String类支持“+”和“+=”。

## 3.3 优先级

请注意，System.out.println()语句中包含“+”操作符。在这种上下文环境中，“+”意味着“字符串连接”，并且如果必要，它还要执行“字符串转换”。当编译器观察到一个String后面紧跟一个“+”，而这个“+”的后面又紧跟一个非String类型的元素时，就会尝试着将这个非String类型的元素转换为String。正如在输出中所看到的，它成功地将a和b从int转换为String了。

## 3.4 赋值

赋值使用操作符“=”。它的意思是“取右边的值（即右值），把它复制给左边（即左值）”。右值可以是任何常数、变量或者是表达式（只要它能生成一个值就行）。但左值必须是一个明确的，已命名的变量。也就是说，必须有一个物理空间可以存储等号右边的值。举例来说，可将一个常数赋给一个变量，但是不能把任何东西赋给一个常数，常数不能作为左值。

对基本数据类型的赋值是很简单的。基本类型存储了实际的数值，而并非指向一个对象的引用，所以在为其赋值的时候，是直接将一个地方的内容复制到了另一个地方。例如，对基本数据类型使用a=b，那么b的内容就复制给a。若接着又修改了a，而b根本不会受这种修改的影响。作为程序员，这正是大多数情况下我们所期望的。

但是在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是对对象的引用。所以倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到另一个地方。这意味着假若对对象使用c=d, 那么c和d都指向原本只有d指向的那个对象。下面这个例子将向大家阐示这一点。

这种特殊的现象通常称作“别名现象”，是Java操作对象的一种基本方式。在这个例子中，如果想避免别名问题应该怎么办呢？可以这样写：` t1.level=t2.level; `

这样便可以保证两个对象彼此独立，而不是将t1和t2绑定到相同的对象。但你很快就会意识到，直接操作对象内的域容易导致混乱，并且，违背了良好的面向对象程序设计的原则。这可不是一个小问题，所以从现在开始大家就应该留意，为对象赋值可能会产生意想不到的结果。

### 3.4.1 方法调用中的别名问题

```java
class Letter{
    char c;
}
static void f(Letter y){
    y.c ='z';
}
```

在许多编程语言中，方法f（）似乎要在它的作用域内复制其参数Letter y的一个副本，但实际上只是传递了一个引用。所以代码行 ` y.c='z'; `实际改变的是f()之外的对象。

## 3.5 算术操作符

通过Random类的对象，程序可生成许多不同类型的随机数字。做法很简单，只需调用方法nextInt()和nextFloat()即可（也可以调用nextLong()或者nextDouble()）。传递给nextInt()的参数设置了所产生的随机数的上限。

### 3.5.1 一元加、减操作符

编译器能正确识别下述语句：

`  x=a*-b`

但读者会被搞糊涂，所以有时更明确地写成：

` x=a*(-b) `

一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小类型的操作数提升为int。

## 3.6 自动递增和递减

“--”和“++”各有两种使用方式，通常称为“前缀式”和“后缀式”。

对于前缀递增和前缀递减（如++a或--a），会先执行运算，再生成值。而对于后缀递增和后缀递减（如a++或a--）,会先生成值，再执行运算。

前缀形式，我们在执行完运算才得到值。但对于后缀形式，则是在运算执行前就得到值。它们是除那些涉及赋值的操作符以外，唯一具有“副作用”的操作符。也就是说，它们会改变操作数，而不仅仅是使用自己的值。

Bill Joy（Java创始人之一）声称“Java=c++--”

## 3.7 关系操作符

关系操作符生成的是一个boolean（布尔）结果，它们计算的是操作数的值之间的关系。关系操作符包括<,>,<=,>=,==以及!=。等于和不等于适用于所有的基本数据类型，而其他比较符不适用于boolean类型。因为boolean值只能为true或false，“大于”和“小于”没有实际意义。

### 3.7.1 测试对象的等价性

```java
Integer n1 = new Integer(47);
Integer n2 = new Integer(47);
System.out.println(n1==n2);
System.out.println(n1!=n2);
```



尽管对象的内容相同，然而对象的引用却是不同的，而==和！=比较的就是对象的引用。所以输出结果实际上先是false，再是true。这自然会使第一次接触关系操作符的人感到惊奇。

如果想比较两个对象的实际内容是否相同，又该如何操作呢？此时，必须使用所有对象都适用的特殊方法equals（）。但这个方法不适用于“基本类型”，基本类型直接使用==和！=即可。

equals()的默认行为是比较引用。所以除非在自己的新类中覆盖equals()方法，否则不可能表现出我们希望的行为。

大多数Java类库都实现了equals()方法，以便用来比较对象的内容，而非比较对象的引用。

## 3.8 逻辑操作符

逻辑操作符“与”（&&）、“或”（||）、“非”（!）能根据参数的逻辑关系，生成一个布尔值（true或false）。

“与”、“或”、“非”操作只可应用于布尔值。与在C及C++中不同的是：不可将一个非布尔值当作布尔值在逻辑表达式中使用。

注意，如果在应该使用String值的地方使用了布尔值，布尔值会自动转换成适当的文本形式。

### 3.8.1 短路

当使用逻辑操作符时，我们会遇到一种“短路”现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算。

事实上，如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升。

## 3.9 直接常量

直接常量后面的后缀字符标志了它的类型。若为大写（或小写）的L，代表long（但是，使用小写字母l容易造成混淆，因为它看上去很像数字1）。大写（或小写）字母F，代表float；大写（或小写）字母D则代表double.

十六进制数适用于所有整数数据类型，以前缀0x（或0X），后面跟随0-9或小写（或大写）的a-f来表示。如果试图将一个变量初始化成超出自身表示范围的值（无论这个值的数值形式如何），编译器都会向我们报告一条错误信息。char、byte以及short如果超出范围，编译器会将值自动转换成int型，并告诉我们需要对这次赋值进行“窄化转型”（转型将在本章稍后部分定义）。这样我们就可清楚地知道自己的操作是否越界了。

八进制数由前缀0以及后序的0~7的数字来表示。

在C、C++或者Java中，二进制数没有直接常量表示方法。但是在使用十六进制和八进制计数法时，以二进制形式显示结果将非常有用。通过使用Integer和Long类的静态方法toBinaryString()可以很容易地实现这一点。请注意，如果将比较小的类型传递给Integer.toBinaryString()方法，则该类型将自动被转换为int。

### 3.9.1 指数计数法

编译器通常会将指数作为双精度数（double）处理。

## 3.10 按位操作符

按位操作符来源于C语言面向底层的操作，Java的设计初衷是嵌入电视机机顶盒内，所以这种面向底层的操作仍被保留了下来。但是，人们可能不会过多的用到位操作符。

与（&）、或（|）、异或（^）、非（~）

按位操作符和逻辑操作符使用了同样的符号，因此我们能方便地记住它们的含义；由于位是非常“小”的，所以按位操作符仅使用了一个字符。

按位操作符可与等号（=）联合使用，以便合并运算和赋值：&=、！=和^=都是合法的（由于“~”是一元操作符，所以不可与“=”联合使用）。

我们将布尔类型作为一种单比特值对待，所以它多少有些独特。我们可对它执行按位“与”、按位“或”和按位“异或”运算，但不能执行按位“非”（大概是为了避免与逻辑NOT混淆）。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是它们不会中途“短路”。此外，针对布尔值进行的按位运算为我们新增了一个“异或”逻辑操作符，它并未包括在“逻辑”操作符的列表中。在移位表达式中，不能使用布尔值运算，原因将在后面解释。

## 3.11 移位操作符

左移位操作符(<<)低位补0

“有符号”右移位操作符(>>)符号为正，高位补0；符号为负，高位补1。Java中增加了一种“无符号”右移位操作符(>>>)，它使用“零扩展”：无论正负，都在高位插入0.这一操作符是C/C++中没有的。

如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转换为int类型，并且得到的结果也是一个int类型的值。只有数值右端的低5位才有用。这样可放置我们移位超过int型值所具有的位数。（译注：因为2^5=32，而int型值只有32位。）若对一个long类型的数值进行处理，最后得到的结果也是long，此时只会用到数值右端的低6位，以防止移位超过long型数值具有的位数。

“移位”可与“等号”（<<=或>>=或>>>=）组合使用。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋给左边的变量。但在进行“无符号”右移位结合赋值操作时，可能会遇到一个问题：如果对byte或short值进行这样的移位运算，得到的可能不是正确的结果。它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。

程序末尾调用了两个方法：printBinaryInt()和printBinaryLong().它们分别接受int或long型的参数，并用二进制格式输出，同时附有简要的说明文字。

## 3.12 三元操作符if-else

## 3.13 字符串操作符+和+=

这个操作符在Java中有一项特殊用途：连接不同的字符串。尽管与+和+=的传统使用方式不太一样，但我们还是很自然地使用这些操作符来做这件事情。

这项功能用在C++中似乎是个不错的注意，所以引入了**操作符重载（operator overloading）**机制，以便C++程序员可以为几乎所有操作符增加功能。与C++相比，尽管操作符重载在Java中更易实现（就像在C#语言中所展示的那样，它具有相当简单直接的操作符重载机制），但仍然过于复杂。所以Java程序员不像C++和C#程序员那样实现自己的重载操作符。

字符串操作有一些很有趣的行为。如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串型（请记住，编译器会把双引号内的字符序列自动转成字符串）。

有时会看到一个空的String（""）后面跟随+和一个基本类型变量，以此作为不调用更加麻烦的显式方法（在本例中应该是Integer.toString()）而执行字符串转换的方式。

## 3.14 使用操作符时常犯的错误

使用操作符时一个常犯的错误就是，即使对表达式如何计算有点不确定，也不愿意使用括号。这个问题在Java中仍然存在。

在C和C++中，一个特别常见的错误如下：

```c
while(x=y){
	//……
}
```

程序员很明显是想测试是否“相等”（==），而不是进行赋值操作。在C和C++中，如果y是一个非零值，那么这种赋值的结果肯定是true，而这样便会得到一个无穷循环。在Java中，这个表达式的结果并不是布尔值，而编译器期望的是一个布尔值。由于Java不会自动地将int数值转换成布尔值，所以在编译时会抛出一个编译时错误，从而阻止我们进一步去运行程序。所以这种错误在Java中永远不会出现（唯一不会得到编译时错误的情况是x和y都为布尔值。在这种情况下，x=y属于合法表达式。而在前面的例子中，则可能是一个错误）。

Java中有一个与C和C++中类似的问题，即使用按位“与”和按位“或”代替逻辑“与”和逻辑“或”。按位“与”和按位“或”使用单字符（&或|），而逻辑“与”和逻辑“或”使用双字符（&&或||）。就像“=”和“==”一样，键入一个字符当然要比键入两个简单。Java编译器可防止这个错误发生，因为它不允许我们随便把一种类型当做另一种类型来用。

## 3.15 类型转换操作符

在适当的时候，Java会将一种数据类型自动转换成另一种。例如，假设我们为某浮点变量赋以一个整数值，编译器会将int自动转换成float。类型转换运算允许我们显式地进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。

想要执行类型转换，需要将希望得到的数据类型置于圆括号内，放在要进行类型转换的值的左边。

在C和C++中，类型转换有时会让人头疼。但是在Java中，类型转换则是一种比较安全的操作。然而，如果要执行一种名为**窄化转换（narrowing conversion）**的操作（也就是说，将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型），就有可能面临信息丢失的危险。此时，编译器会强制我们进行类型转换。而对于**扩展转换（widening conversion）**,则不必显式地进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。

Java允许我们把任何基本数据类型转换成别的基本数据类型，但布尔型除外，后者根本不允许进行任何类型的转换处理。“类”数据类型不允许进行类型转换。为了将一种类转换成另一种，必须采用特殊的方法（本书后面会讲到，对象可以在其所属类型的类族之间可以进行类型转换；例如，“橡树”可转型为“树”；反之亦然。但不能把它转换成类族以外的类型，如“岩石”）。

### 3.15.1 截尾和舍入

在执行窄化转换时，必须注意截尾与舍入问题。

float或double转型为整型值时，总是对该数字执行截尾。若果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法；

round()是java.lang的一部分，因此在使用它时不需要额外地导入。

### 3.15.2 提升

如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（即char、byte或者short），那么在运算之前，这些值会自动转换成int。这样一来，最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转换（既然把结果赋给了较小的类型，就可能出现信息丢失）。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。如果将一个float值与一个double值相乘，结果就是double;如果将一个int和一个long值相加，则结果为long。

## 3.16 Java没有sizeof

在C和C++中，需要sizeof()的最大原因是为了“移植”。

Java不需要sizeof()操作符，因为所有数据类型在所有机器中的大小都是相同的。我们不必考虑移植问题——它已经被设计在语言中了

## 3.17 操作符小结

|           | boolean |  char   |  byte   |  short   | int  | long | float | double |
| :-------: | :-----: | :-----: | :-----: | :------: | :--: | :--: | :---: | :----: |
|     *     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     /     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     %     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     +     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     -     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|    ++     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    --     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|  +(一元)  |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
| -（一元） |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |   ✔   |   ✔    |
|     >     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    >=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|     <     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    <=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    ==     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    !=     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|     !     |    ✔    |         |         |          |      |      |       |        |
|    &&     |    ✔    |         |         |          |      |      |       |        |
|   \|\|    |    ✔    |         |         |          |      |      |       |        |
|     ~     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|     &     |    ✔    | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    \|     |    ✔    | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|     ^     |    ✔    | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    <<     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    >>     |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    >>>    |         | (char)✔ | (byte)✔ | (short)✔ |  ✔   |  ✔   |       |        |
|    +=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    -=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    *=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    /=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    %=     |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|    <<=    |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    >>=    |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|   >>>=    |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    &=     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    ^=     |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|    \|=    |    ✔    |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |       |        |
|  (char)   |         |    -    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|  (byte)   |         |    ✔    |    -    |    ✔     |  ✔   |  ✔   |   ✔   |   ✔    |
|  (short)  |         |    ✔    |    ✔    |    -     |  ✔   |  ✔   |   ✔   |   ✔    |
|   (int)   |         |    ✔    |    ✔    |    ✔     |  -   |  ✔   |   ✔   |   ✔    |
|  (long)   |         |    ✔    |    ✔    |    ✔     |  ✔   |  -   |   ✔   |   ✔    |
|  (float)  |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   -   |   ✔    |
| (double)  |         |    ✔    |    ✔    |    ✔     |  ✔   |  ✔   |   ✔   |   -    |
| (boolean) |    -    |         |         |          |      |      |       |        |

注意，能够对布尔型值进行的运算非常有限。我们只能赋予它true和false值，并测试它为真还是为假，而不能将布尔值相加，或对布尔值进行其他任何运算。

在char\byte和short中，我们可以看到使用算术操作符中数据类型提升的效果。对这些类型的任何一个进行算术运算，都会获得一个int结果，必须将其显式地类型转换回原来的类型（窄化转换可能会造成信息的丢失），以将值赋给原本的类型。但对于int值，却不必进行类型转化，因为所有数据都已经属于int类型。但对两个足够大的int值进行乘法运算，结果就会溢出，你不会从编译器那里收到出错或警告信息，运行时也不会出现异常。这说明Java虽然是好东西，但也没有那么好！

对于char\byte或者short，复合赋值并不需要类型转换。尽管它们执行类型提升，但也会获得与直接算术运算相同的结果。而在另一方面，省略类型转换可使代码更加简练。

可以看到，除boolean以外，任何一种基本类型都可通过类型转换变为其他基本类型。