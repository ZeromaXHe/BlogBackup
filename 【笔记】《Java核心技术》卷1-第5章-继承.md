# 第5章 继承

继承（inheritance）

反射（reflection）

## 5.1 类、超类和子类

关键字extends表示继承。

*C++注释：Java与C++定义继承类的方式十分相似。Java用关键字extends代替了C++中的冒号（：）。在Java中，所有的继承都是共有继承，而没有C++中的私有继承和保护继承。*

关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为**超类（superclass）**、**基类（base class）**或**父类（parent class）**；新类称为**子类(subclass)**、**派生类（derived class）**或**孩子类（child class）**。超类和子类是Java程序员最常用的两个术语，而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这些都是继承时使用的术语。

*注释：前缀“超”和“子”来源于计算机科学和数学理论中的集合语言的术语。所有雇员组成的集合包含所有经理组成的集合。可以这样说，雇员集合是经理集合的超级，也可以说，经理级和是雇员集合的子集。*

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此，在设计类的时候，应该将通用的方法放在超类中，而将特殊用途的方法放在子类中。

但，超类中的有些方法对子类不一定适用，为此需要提供一个新的方法来**覆盖（override）**超类中的这个方法。

子类方法不能够直接访问超类的私有域。一定要访问私有域的话，就必须借助于共有的接口，如getSalary()。我们希望调用超类的方法，而不是当前类的这个方法，可以适用关键字super解决这个问题。

*注释：有人认为super和this引用是类似的概念，实际上，这种比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。*

子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。

*C++注释：在Java中使用关键字super调用超类的方法，而在C++中则采用超类名加上`::`操作符的形式*

super在构造器中的应用：调用超类构造器。必须是子类构造器的第一条语句。

如果子类构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，而子类构造器又没有显式地调用超类其他构造器，Java编译器将报告错误。

*注释：回忆一下，关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，super关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，这两个关键字的使用方式很相似。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。*

*C++注释：在C++的构造函数中，使用初始化列表语法调用超类的构造函数，而不调用super。*

一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为**多态（polymorphism）**。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定（dynamic binding）**。

*C++注释：在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以将它标记为final（稍后介绍关键字final）。*

### 5.1.1 继承层次

由一个公共超类派生出来的所有类的集合被称为**继承层次（inheritance hierarchy）**。在继承层次中，从某个特定的类到其祖先的路径被称为该类的**继承链（inheritance chain）**。

*C++注释：Java不支持多继承。有关Java中多继承功能的实现方式，请参看下一章6.1节有关接口的讨论。*

### 5.1.2 多态

有一个用来判断是否应该设计为继承关系的简单规则，这就是"is-a"规则，它表明子类的每一个对象也是超类的对象。

"is-a"规则的另一种表述法是**置换法则**。它表明程序中出现超类对象的任何地方都可以用子类对象置换。

在Java中，对象变量是多态的。一个变量既可以引用本类的对象，也可以引用子类的对象。

``` java
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0]=boss;
```

在这个例子中，变量staff[0]与boss引用同一对象。但编译器将staff[0]看成Employee对象，所以不能调用Manager类的setBonus方法。而boss可以。

*警告：在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。下面是一个经理数组`Manager[] manager = new Manager[10];`将它转换成Employee[]数组是完全合法的：`Employee[] staff = managers;`。然而这样之后，manager和staff引用了同一数组。现在看这条语句：`staff[0] = new Employee("Harry Hacker", ...);` 编译器竟然接纳了这个赋值操作。但在这里，staff[0]与manager[0] 引用的是同一个对象，似乎我们把一个普通雇员擅自归入经理行列中了。这是一种很忌讳发生的情形，当调用managers[0].setBonus(1000)的时候，将会导致调用一个不存在的实例域，进而搅乱相邻存储空间的内容。*

*为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。*

*如果试图存储一个Employee类型的引用就会引发ArrayStoreException异常*

### 5.1.3 动态绑定

调用过程的详细描述：

1） 编译器查看对象的声明类型和方法名。可能存在多个名字相同为f，参数类型不一样的方法。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。

至此，编译器已获得所有可能被调用的候选方法。

2）接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析（overloading resolution）**。由于允许类型转换，所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。

至此，编译器已获得需要调用的方法名字和参数类型。

*注释：前面曾经说过，方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。*

*不过返回类型不是签名的一部分。因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。我们说这两个方法具有可协变的返回类型。*

3） 如果是private方法、static方法、final方法（有关final修饰符的含义在下一章表述）或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定（static binding）**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f(String)的指令。

4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。先在本类寻找，没有就去超类中寻找。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个**方法表（method table）**，其中列出了所有方法的签名和实际调用的方法。这样依赖，在真正调用方法的时候，虚拟机仅查找这个表就行了。这里要提醒一点，如果调用super.f(param)。编译器将对隐式参数超类方法表进行搜索。

动态绑定有一个非常重要的特性：无需对现存代码进行修改，就可以对程序进行扩展。

*警告：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。*

### 5.1.4 阻止继承：final类和方法

有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。

*注释：前面曾经说过，域也可以被声明为final。对于final域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域。*