# 第5章 继承

继承（inheritance）

反射（reflection）

## 5.1 类、超类和子类

关键字extends表示继承。

*C++注释：Java与C++定义继承类的方式十分相似。Java用关键字extends代替了C++中的冒号（：）。在Java中，所有的继承都是共有继承，而没有C++中的私有继承和保护继承。*

关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为**超类（superclass）**、**基类（base class）**或**父类（parent class）**；新类称为**子类(subclass)**、**派生类（derived class）**或**孩子类（child class）**。超类和子类是Java程序员最常用的两个术语，而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这些都是继承时使用的术语。

*注释：前缀“超”和“子”来源于计算机科学和数学理论中的集合语言的术语。所有雇员组成的集合包含所有经理组成的集合。可以这样说，雇员集合是经理集合的超级，也可以说，经理级和是雇员集合的子集。*

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此，在设计类的时候，应该将通用的方法放在超类中，而将特殊用途的方法放在子类中。

但，超类中的有些方法对子类不一定适用，为此需要提供一个新的方法来**覆盖（override）**超类中的这个方法。

子类方法不能够直接访问超类的私有域。一定要访问私有域的话，就必须借助于共有的接口，如getSalary()。我们希望调用超类的方法，而不是当前类的这个方法，可以适用关键字super解决这个问题。

*注释：有人认为super和this引用是类似的概念，实际上，这种比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。*

子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。

*C++注释：在Java中使用关键字super调用超类的方法，而在C++中则采用超类名加上`::`操作符的形式*

super在构造器中的应用：调用超类构造器。必须是子类构造器的第一条语句。

如果子类构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，而子类构造器又没有显式地调用超类其他构造器，Java编译器将报告错误。

*注释：回忆一下，关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，super关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，这两个关键字的使用方式很相似。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。*

*C++注释：在C++的构造函数中，使用初始化列表语法调用超类的构造函数，而不调用super。*

一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为**多态（polymorphism）**。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定（dynamic binding）**。

*C++注释：在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以将它标记为final（稍后介绍关键字final）。*

### 5.1.1 继承层次

由一个公共超类派生出来的所有类的集合被称为**继承层次（inheritance hierarchy）**。在继承层次中，从某个特定的类到其祖先的路径被称为该类的**继承链（inheritance chain）**。

*C++注释：Java不支持多继承。有关Java中多继承功能的实现方式，请参看下一章6.1节有关接口的讨论。*

### 5.1.2 多态

有一个用来判断是否应该设计为继承关系的简单规则，这就是"is-a"规则，它表明子类的每一个对象也是超类的对象。

"is-a"规则的另一种表述法是**置换法则**。它表明程序中出现超类对象的任何地方都可以用子类对象置换。

在Java中，对象变量是多态的。一个变量既可以引用本类的对象，也可以引用子类的对象。

``` java
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0]=boss;
```

在这个例子中，变量staff[0]与boss引用同一对象。但编译器将staff[0]看成Employee对象，所以不能调用Manager类的setBonus方法。而boss可以。

*警告：在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。下面是一个经理数组`Manager[] manager = new Manager[10];`将它转换成Employee[]数组是完全合法的：`Employee[] staff = managers;`。然而这样之后，manager和staff引用了同一数组。现在看这条语句：`staff[0] = new Employee("Harry Hacker", ...);` 编译器竟然接纳了这个赋值操作。但在这里，staff[0]与manager[0] 引用的是同一个对象，似乎我们把一个普通雇员擅自归入经理行列中了。这是一种很忌讳发生的情形，当调用managers[0].setBonus(1000)的时候，将会导致调用一个不存在的实例域，进而搅乱相邻存储空间的内容。*

*为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。*

*如果试图存储一个Employee类型的引用就会引发ArrayStoreException异常*

### 5.1.3 动态绑定

调用过程的详细描述：

1） 编译器查看对象的声明类型和方法名。可能存在多个名字相同为f，参数类型不一样的方法。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。

至此，编译器已获得所有可能被调用的候选方法。

2）接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析（overloading resolution）**。由于允许类型转换，所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。

至此，编译器已获得需要调用的方法名字和参数类型。

*注释：前面曾经说过，方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。*

*不过返回类型不是签名的一部分。因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。我们说这两个方法具有可协变的返回类型。*

3） 如果是private方法、static方法、final方法（有关final修饰符的含义在下一章表述）或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定（static binding）**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f(String)的指令。

4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。先在本类寻找，没有就去超类中寻找。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个**方法表（method table）**，其中列出了所有方法的签名和实际调用的方法。这样依赖，在真正调用方法的时候，虚拟机仅查找这个表就行了。这里要提醒一点，如果调用super.f(param)。编译器将对隐式参数超类方法表进行搜索。

动态绑定有一个非常重要的特性：无需对现存代码进行修改，就可以对程序进行扩展。

*警告：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。*

### 5.1.4 阻止继承：final类和方法

有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。

*注释：前面曾经说过，域也可以被声明为final。对于final域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域。*

将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。

**内联（inline）**：一个方法没被覆盖而且很短，编译器能够对它进行优化处理

### 5.1.5 强制类型转换

子类的引用赋给一个超类，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。

instanceof运算符

*注释：x为null，x instanceof C不会产生异常，只是返回false*

尽量少用类型转换和instanceof运算符。

*C++注释：C++dynamic_cast操作*

### 5.1.6 抽象类

只将它作为派生其他类的基类，而不作为想使用的特定实例类。

包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。

*提示：建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中*

抽象方法充当着占位的角色，它们的具体实现在子类中。子类中定义部分抽象方法或抽象方法也不定义，则必须将子类标记为抽象类。全部定义抽象方法才不是抽象的。

类即使不含抽象方法，也可以将类声明为抽象类。

抽象类不能实例化。可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。

*C++注释：尾部用=0标记的抽象方法，称为纯虚函数。有一个纯虚函数，这个类就是抽象类。C++没有提供用于表示抽象类的特殊关键字。*

### 5.1.7 受保护访问

protected，允许子类访问。

*C++注释：Java中的protected概念要比C++中的安全性差。*

## 5.2 Object：所有类的超类

Object类是Java所有类的始祖，在Java中每个类都是由它扩展来的。

如果没有明确指明超类，Object就被认为是这个类的超类。

可以使用Object类型引用任何类型的对象。

在Java中，只有基本类型（primitive types）不是对象。==所有的数组类型，不管是对象数组还是基本类型数组都扩展于Object类。==

*C++注释：在C++中没有所有类的根类，不过每个指针都可以转换为void\*指针。*

### 5.2.1 equals方法

在Object类中，这个方法将判断两个对象是否具有相同的引用。

getClass方法返回一个对象所属的类。

*提示：为了防备.equals前的变量可能为null的情况，需要使用Object.equals(a, b)方法。*

### 5.2.2 相等测试与继承

如果隐式和显式的参数不属于同一个类，equals方法如何处理？类不匹配，返回false。许多程序员喜欢使用instanceof来进行检测，这样做不但没有解决otherObject是子类的情况，并且可能招致一些麻烦。所以不建议使用这种方式。

Java语言规范要求equals方法具有下面特性：

1）自反性

2）对称性

3）传递性

4）一致性

5）非空引用x.equals(null)应该返回false。

下面可以从两个截然不同的情况看一下这个问题：

- 如果子类能够拥有自己相等概念，则对称性需求将强制采用getClass进行检测。
- 如果超类决定相等概念，那么就可以使用instanceof进行检测，这样可以在不用子类对象之间进行相等的比较。

*注释：标准Java库中包含150多个equals方法实现，包括使用instanceof检测、调用getClass检测、捕获ClassCastException或者什么也不做。*

下面给出编写一个完美的equals方法的建议：

1. 显式参数命名为otherObject， 稍后需要将它转换成另一个叫做other的变量。
2. 检测this与otherObject是否引用同一个对象。
3. 检测otherObject是否为null，如果为null，返回false。
4. 比较this与otherObject是否属于同一类。如果equals的语义在每个子类中有所改变，就用getClass检测。如果都有子类都有统一的语义，就用instanceof检测。
5. 将otherObject转换为相应的类类型变量
6. 现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。

如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。

*提示：对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。*

*警告：可以使用@Override对覆盖超类的方法进行标记。*

【API】java.util.Arrays 1.2

- `static Boolean equals(type[] a, type[] b)` 5.0

【API】java.util.Objects 7

- `static boolean equals(Object a, Object b)`

### 5.2.3 hashCode方法

**散列码（hash code）**是由对象导出的一个整型值。

hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。

字符串的散列码是由内容导出的。而没有定义hashCode方法的类的散列码是由Object类的默认hashCode方法导出的对象存储地址。

如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中。

hashCode方法应该返回一个整型数值（也可以是负数），并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。

Java 7中可以做两个改进。首先，最好使用null安全的方法Objects.hashCode. 需要组合多个散列值时，可以调用Object.hash并提供多个参数。这个方法会对各个参数调用Object.hashCode，并组合这些散列值。

*提示：如果存在数组类型的域，那么可以使用静态的Arrays.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成。*

【API】java.lang.Object 1.0

- `int hashCode()`

【API】java.lang.Objects 7

- `int hash(Object... objects)`
- `static int hashCode(Object a)`

【API】java.util.Arrays 1.2

- static int hashCode(type[] a) 5.0

### 5.2.4 toString方法

