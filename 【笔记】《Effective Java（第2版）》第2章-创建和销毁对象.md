# 第2章 创建和销毁对象

## 第1条：考虑用静态工厂方法代替构造器

静态工厂方法（static factory method），它只是一个返回类的实例的静态方法。

```java
public static Boolean valueOf(boolean b){
    return b?Boolean.TRUE:Boolean.FALSE;
}
```

注意：静态工厂方法与设计模式中的工厂方法模式不同。本条目中所指的静态工厂方法并不直接对应于设计模式中的工厂方法。

提供静态工厂而不是公有的构造器，这样做有几大优势。

**静态工厂方法与构造器不同的第一大优势在于，它们有名称。**如果构造器的参数本身没有确切地描述正被返回的对象，那么具有恰当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读。例如，构造器BigInteger(int, int, Random)返回的BigInteger可能为素数，如果用名为BigInteger.probablePrime的静态工厂方法来表示，显然更为清楚。（1.4最终增加了这个方法）

一个类只能有一个带有指定签名的构造器。

由于静态工厂方法有名称，所以它们不受上述的限制。当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重选择名称以便突出它们之间的区别。

**静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。**这使得不可变类（见第15条）可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。Boolean.valueOf(boolean)方法说明了这项技术：它从来不创建对象。这种方法类似于Flyweight模式。

静态工厂方法能够为重复的调用返回相同的对象，这有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作**实例受控的类（instance-controlled）**。实例受控使得类可以确保它是一个Singleton（见第3条）或者是不可实例化的（见第4条）。它还使得不可变的类（见第15条）可以确保不会存在两个相等的实例。

**静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。**这样我们在选择返回对象的类时就有了更大的灵活性。

这种灵活性的一种应用是，API可以返回对象，同时又不会使对象的类变成公有的。以这种方式隐藏实现类会使API变得非常简洁。这项技术适用于基于接口的框架（interface-based framework，见第18条），因为在这种框架中，接口为静态工厂方法提供了自然返回类型。接口不能有静态方法，因此按照管理，接口Type的静态工厂方法被放在一个名为Types的不可实例化的类（见第4条）中。

静态工厂方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在。这种灵活的静态工厂方法构成了**服务提供者框架（Service Provider Framework）**的基础，例如JDBC（Java数据库连接，Java Database Connectivity）API。服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。