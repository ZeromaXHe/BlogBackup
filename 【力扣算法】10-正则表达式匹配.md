# 题目

给定一个字符串 (`s`) 和一个字符模式 (`p`)。实现支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖**整个**字符串 (`s`) ，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

**示例 3:**

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

**示例 4:**

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5:**

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

# 题解

无官方题解，下面贴我自己的解答

执行用时 : 137 ms, 在Regular Expression Matching的Java提交中击败了37.10% 的用户

内存消耗 : 43.6 MB, 在Regular Expression Matching的Java提交中击败了62.24% 的用户

主要用的递归解决的，感觉很多地方在重复计算，有点蠢。所以跑得很慢。

可以使用动态规划优化一下的，但做了一晚上没什么心情了，先贴一份递归法解决的，日后有机会再优化了更新一下blog。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        if("".equals(s)||"".equals(p)){
            return dealWithEnd(s,p);
        }
        if(p.charAt(0)=='.'){
            if(p.length()>1&& p.charAt(1)=='*'){
                return pointStarMatch(s,p);
            }
            else{
                return isMatch(s.substring(1),p.substring(1));
            }
        }
        else {
            if(p.length()>1&& p.charAt(1)=='*'){
                return characterStarMatch(s,p);
            }
            else{
                return singleMatch(s,p);
            }
        }
    }
    boolean singleMatch(String s,String p){
        //System.out.println("检查单个字母"+s.charAt(0));
        if(s.charAt(0)==p.charAt(0)) return isMatch(s.substring(1),p.substring(1));
        else return false;
    }
    boolean characterStarMatch(String s,String p){
        //System.out.println("检查字母加星号"+p.charAt(0)+"*");
        char p0=p.charAt(0);
        if("".equals(s)) return dealWithEnd(s,p);
        if(s.charAt(0)==p0){
            if(characterStarMatch(s.substring(1),p)||isMatch(s,p.substring(2))){
                return true;
            }
        }
        else{
            if(isMatch(s,p.substring(2))){
                return true;
            }
        }
        return false;

    }
    boolean pointStarMatch(String s,String p){
        if("".equals(s)) return dealWithEnd(s,p);
        if(isMatch(s,p.substring(2))||pointStarMatch(s.substring(1),p)) return true;

        return false;
    }
    boolean dealWithEnd(String aS, String aP){
        if((!"".equals(aS) && "".equals(aP))) return false;
        else{
            if("".equals(aS)&&!"".equals(aP)){
                if(aP.length()%2==0){
                    int pos=1;
                    while(pos<aP.length()){
                        if(aP.charAt(pos)!='*') return false;
                        pos+=2;
                    }
                    return true;
                }
                else return false;
            }
            else return true;//aS和aP全部是空的
        }
    }
}
```

一开始自己有些思路都是从底下想按动态规划备忘录方法往上走的，但走着走着自己思路就糊了。。。

递归法还是比较直观，从上往下。但是自己还是会傻乎乎地想用循环，其实改改递归条件就可以了。循环应该是动归备忘录才要。

# 感想

贴一下自己调试的代码吧，写的也挺蠢的，全是static。。。

开头的注释都是bug过的案例。主要就是递归那边判定条件有点难搞，所以调了一晚上。。。做了差不多3h，提交了16次。。。自己还是太菜了

```java
public class SublimeTextTest{
	public static void main(String[] args){
		
		String s = "a";		//"aaa";//"ab"; //"mississippi";//"aa"//"ab"//"aab"
		String p = ".*..a*"; //"a*a";//".*c";//"mis*is*p*."  //"a*"//".*"//"c*a*b"
		boolean output = Solution.isMatch(s,p);
		System.out.println(output);
	}
}
class Solution {
    static public boolean isMatch(String s, String p) {
        if("".equals(s)||"".equals(p)){
            return dealWithEnd(s,p);
        }
        if(p.charAt(0)=='.'){
            if(p.length()>1&& p.charAt(1)=='*'){
                return pointStarMatch(s,p);
            }
            else{
                return isMatch(s.substring(1),p.substring(1));
            }
        }
        else {
            if(p.length()>1&& p.charAt(1)=='*'){
                return characterStarMatch(s,p);
            }
            else{
                return singleMatch(s,p);
            }
        }
    }
    static boolean singleMatch(String s,String p){
    	System.out.println("检查单个字母"+s.charAt(0)+":"+s+","+p);
        if(s.charAt(0)==p.charAt(0)) return isMatch(s.substring(1),p.substring(1));
        else return false;
    }
    static boolean characterStarMatch(String s,String p){
    	System.out.println("检查字母加星号"+p.charAt(0)+"*"+":"+s+","+p);
        char p0=p.charAt(0);
        if("".equals(s)) return dealWithEnd(s,p);
        if(s.charAt(0)==p0){
        	if(characterStarMatch(s.substring(1),p)||isMatch(s,p.substring(2))){
        		return true;
        	}
        }
        else{
        	if(isMatch(s,p.substring(2))){
        		return true;
        	}
        }
        return false;

    }
    static boolean pointStarMatch(String s,String p){
    	System.out.println("检查.*"+":"+s+","+p);
        if("".equals(s)) return dealWithEnd(s,p);
        if(isMatch(s,p.substring(2))||pointStarMatch(s.substring(1),p)) return true;

        return false;
    }
    static boolean dealWithEnd(String aS, String aP){
    	System.out.println("处理空情况"+":"+aS+","+aP);
        if((!"".equals(aS) && "".equals(aP))) return false;
        else{
            if("".equals(aS)&&!"".equals(aP)){
                if(aP.length()%2==0){
                    int pos=1;
                    while(pos<aP.length()){
                        if(aP.charAt(pos)!='*') return false;
                        pos+=2;
                    }
                    return true;
                }
                else return false;
            }
            else return true;//aS和aP全部是空的
        }
    }
}
```

