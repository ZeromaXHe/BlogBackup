# 第1章 算法引论 习题

**1-1** 说明下面方法swap为什么无法交换实际参数的值。

```
答：java基本数据类型传值，方法不会改变实参的值。
书中原文为——java中所有方法的参数均为值参数。在调用方法时先将实际参数的值复制到形式参数中，然后再执行调用。因此，在执行调用后，实际参数的值不变。
（思考：所以要用javabean？如果要实现swap，必须引入getter&setter？）
```

**1-2** 说明下面的两个方法头是否有不同的签名，为什么？

```
答：签名是指方法名加参数列表。所以两者均为fff+（int, int, int），签名相同。
```

**1-3** 写一个通用方法用于判定给定数组是否已排好序。

```java
public static boolean checkOrder(int a[]){
    int temp;
    int order=0;
    for(int i=0;i<a.length;i++){
        if(i==0) temp=a[i];
        else if(order!=0){
            if(order==1 && a[i]>=temp) temp=a[i];
            else if(order==-1 && a[i]<=temp) temp=a[i];
            else return false;
        }
        else {
            if(a[i]>temp) order=1;
            else if(a[i]<temp) order=-1;
            temp=a[i];
        }
    }
    return true;
}
```

**1-4** 求下列函数的渐进表达式。

(1) 3n^2^+10n

(2) n^2^/10+2^n^

(3) 21+1/n

(4) logn^3^

(5) 10log3^n^

```
(1)O(n^2)
(2)O(2^n)
(3)O(1)
(4)O(log n)
(5)O(n)
```

**1-5** 说明O(1)和O(2)的区别

```
答：仅有表面上数字区别，其实没区别,O(1)=O(2)
```

**1-9** 对于下列各组函数f（n）和g（n），确定f（n）=O(g（n）)或f（n）=Ω（g(n)）或f（n）=θ（g（n）），并简述理由。

```
f（n）的阶不高于g（n）的阶：f(n)=O(g(n))
f(n)的阶不低于g（n）的阶：
f（n）=Ω（g(n)）
（1）θ
（2）O
（3）Ω
（4）Ω
（5）θ
（6）Ω
（7）Ω
（8）O
```

**1-10** 证明：n！=o(n^n^)。

```
n!/(n^n)=(1/n)(2/n)…(n/n)趋近于0
```

**1-11** 证明：如果一个算法在平均情况下的计算时间复杂性为θ（f(n)）,则该算法在最坏情况下所需的计算时间为Ω（f(n)）

```
反证法
假设最坏情况下需要的计算时间为g(n)其中g(n)为O（f(n)）中不为θ（f(n)）的部分。
那么根据平均情况下的计算时间复杂性就会成立θ（f(n)）=O（g(n)）,显然该式无法成立，所以，原命题正确。
```

```
查的答案：
Tavg（N）=∑P（I）T(N,I）
	<=∑P(I)maxT(N,I')
	=T(N,I*)∑P(I)
	=T(N,I*)
	=Tmax(N)
因此Tmax(N)=Ω（Tavg（N））=Ω（θ（f(n)））=Ω（f(n)）
```

