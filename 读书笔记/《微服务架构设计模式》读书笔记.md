# 第3章 微服务架构中的进程间通信

## 3.1 微服务架构中的进程间通信概述

服务可以使用基于同步请求 / 响应的通信机制，例如 HTTP REST 或 gRPC。另外，也可以使用异步的基于消息的通信机制，比如 AMQP 或 STOMP。

消息的格式也不尽相同。服务可以使用具备可读性的格式，比如基于文本的 JSON 或 XML。也可以使用更加高效的、基于二进制的 Avro 或 Protocol Buffers 格式。

### 3.1.1 交互方式

有多种客户端与服务的交互方式。它们可以分为两个维度。

第一个维度关注的是一对一和一对多。

- **一对一**：每个客户端请求由一个服务实例来处理。
- **一对多**：每个客户端请求由多个服务实例来处理。

交互方式的第二个维度关注的是同步和异步。

- **同步模式**：客户端请求需要服务端实时响应，客户端等待响应时可能导致堵塞。
- **异步模式**：客户端请求不会阻塞进程，服务端的响应可以是非实时的。

|              | 一对一                       | 一对多                           |
| ------------ | ---------------------------- | -------------------------------- |
| **同步模式** | 请求 / 响应                  | 无                               |
| **异步模式** | 异步请求 / 响应<br/>单向通知 | 发布 / 订阅 <br/>发布 / 异步响应 |

一对一的交互方式有以下几种类型。

- **请求 / 响应**：一个客户端向服务端发起请求，等待响应；客户端期望服务端很快就会发送响应。在一个基于线程的应用中，等待过程可能造成线程阻塞。这样的方式会导致服务的紧耦合。
- **异步请求 / 响应**：客户端发送请求到服务端，服务端异步响应请求。客户端在等待响应时不会阻塞线程，因为服务端的响应不会马上就返回。
- **单向通知**：客户端的请求发送到服务端，但是并不期望服务端做出任何响应。

一对多的交互方式有以下几种类型：

- **发布 / 订阅方式**：客户端发布通知消息，被零个或多个感兴趣的服务订阅。
- **发布 / 异步响应方式**：客户端发布请求消息，然后等待从感兴趣的服务发回的响应。

### 3.1.2 在微服务架构中定义 API

API 或接口是软件开发的中心。应用是由模块构成的，每个模块都有接口，这些接口定义了模块的客户端可以调用若干操作。一个设计良好的接口会在暴露有用功能同时隐藏实现的细节。因此，这些实现的细节可以被修改，而接口保持不变，这样就不会对客户端产生影响。

无论选择哪种进程间通信机制，使用某种**接口定义语言**（IDL）精确定义服务的API都很重要。

### 3.1.3 API的演化

#### 语义化版本控制

语义化版本控制规范为 API 版本控制提供了有用的指导。它是一组规则，用于指定如何使用版本号，并且以正确的方式递增版本号。语义化版本控制最初的目的是软件包的版本控制，但你可以将其用在分布式系统中对 API 进行版本控制。

语义化版本控制规范（Semvers）要求版本号由三部分组成：MAJOR、MINOR、PATCH。必须按如下方式递增版本号：

- **MAJOR**：当你对 API 进行不兼容的更改时。
- **MINOR**：当你对 API 进行向后兼容的增强时。
- **PATCH**：当你进行向后兼容的错误修复时。

#### 进行次要并且向后兼容的改变

理想情况下，你应该努力只进行向后兼容的更改。向后兼容的更改是对API的附加更改或功能增强：

- 添加可选属性。
- 向响应添加属性。
- 添加新操作。

#### 进行主要并且不向后兼容的改变

如果你使用的是基于 HTTP 的进程间通信机制，例如 REST，则一种方法是在 URL 中嵌入主要版本号。例如，版本 1 路径以 `/v1/...` 为前缀，而版本 2 路径以 `/v2/...` 为前缀。

另一种选择是使用 HTTP 的内容协商机制，并在 MIME 类型中包含版本号。

### 3.1.4 消息的格式

消息的格式可以分为两大类：文本和二进制。我们来逐一分析。

#### 基于文本的消息格式

第一类是 JSON 和 XML 这样的基于文本的格式。这类消息格式的好处在于，它们的可读性很高，同时也是自描述的。JSON 消息是命名属性的集合。相似地，XML 消息也是命名元素和值的集合。这样的格式允许消息的接收方只挑选他们感兴趣的值，而忽略掉其他。

使用基于文本格式消息的弊端主要是消息往往过度冗长，特别是 XML。消息的每一次传递都必须反复包含除了值以外的属性名称，这样会造成额外的开销。另一个弊端是解析文本引入的额外开销，尤其是在消息较大的时候。因此，在对效率和性能敏感的场景下，你可能需要考虑基于二进制格式的消息。

#### 二进制消息格式

有几种不同的二进制格式可供选择。常用的包括 Protocol Buffers 和 Avro。这两种格式都提供了一个强类型定义的 IDL（接口描述文件），用于定义消息的格式。编译器会自动根据这些格式生成序列化和反序列化的代码。

## 3.2 基于同步远程过程调用模式的通信

远程过程调用的工作原理：客户端中的业务逻辑调用**代理接口**，这个接口由**远程过程调用代理**适配器类实现。**远程过程调用代理**向服务发出请求。该请求由**远程过程调用服务器**适配器类处理，该类通过接口调用服务的业务逻辑。然后它将回复发送回**远程过程调用代理**，该代理将结果返回给客户端的业务逻辑。

**代理接口**通常封装底层通信协议。有很多协议可供选择。在本节中，我将介绍 REST 和 gRPC。

### 3.2.1 使用REST

REST 是一种（总是）使用HTTP协议的进程间通信机制，REST 之父 Roy Fielding 曾经说过：

> REST 提供了一系列架构约束，当作为整体使用时，它强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，它强化了安全性，也能封装遗留系统。

REST 中的一个关键概念是**资源**，它通常表示单个业务对象，例如客户或产品，或业务对象的集合。REST 使用 HTTP 动词来操作资源，使用URL引用这些资源。

#### REST成熟度模型

Leonard Richardson为 REST 定义了一个成熟度模型，具体包含以下四个层次。

- **Level 0**：Level 0 层级服务的客户端只是向服务端点发起 HTTP POST 请求，进行服务调用。每个请求都指明了需要执行的操作、这个操作针对的目标（例如，业务对象）和必要的参数。
- **Level 1**：Level 1 层级的服务引入了资源的概念。要执行对资源的操作，客户端需要发出指定要执行的操作和包含任何参数的POST请求。
- **Level 2**：Level 2 层级的服务使用 HTTP 动词来执行操作，譬如 GET 表示获取、POST 表示创建、PUT 表示更新。请求查询参数和主体（如果有的话）指定操作的参数。这让服务能够借助 Web 基础设施服务，例如通过 CDN 来缓存 GET 请求。
- **Level 3**：Level 3 层级的服务基于 HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是在由 GET 请求返回的资源信息中包含链接，这些链接能够执行该资源允许的操作。HATEOAS 的优点包括无须在客户端代码中写入硬链接的 URL。此外，由于资源信息中包含可允许操作的链接，客户端无须猜测在资源的当前状态下执行何种操作。

#### 定义REST API

如前面3.1节所述，你必须使用接口定义语言（IDL）定义API。与旧的通信协议（如 CORBA 和 SOAP）不同，REST 最初没有 IDL。幸运的是，开发者社区重新发现了 RESTful API 的 IDL 价值。最流行的 REST IDL 是 Open API 规范，它是从 Swagger 开源项目发展而来的。Swagger 项目是一组用于开发和记录 REST API 的工具。它包括从接口定义到生成客户端桩（stub，存根）和服务器骨架的一整套工具。

#### 在一个请求中获取多个资源的挑战

设计 REST API 时的一个常见问题是如何使客户端能够在单个请求中检索多个相关对象。更复杂的情况需要更多往返并且遭受过多的延迟。

此问题的一个解决方案是 API 允许客户端在获取资源时检索相关资源。这种方法在许多场景中都很有效，但对于更复杂的场景来说，它通常是不够的。实现它也可能很耗时。这导致替代技术的日益普及，例如 GraphQL 和 Netflix Falcor，它们旨在支持高效的数据获取。

#### 把操作映射为 HTTP 动词的挑战

另一个常见的 REST API 设计问题是如何将要在业务对象上执行的操作映射到 HTTP 动词。REST API 应该使用 PUT 进行更新，但可能有多种方法来更新订单，包括取消订单、修改订单等。此外，更新可能不是幂等的，但这却是使用 PUT 的要求。一种解决方案是定义用于更新资源的特定方面的子资源。另一种解决方案是将动词指定为 URL 的查询参数。可惜的是，这两种解决方案都不是特别符合 RESTful 的要求。

映射操作到 HTTP 动词的这个问题导致了 REST 替代方案的日益普及，例如 gRPC，我将在3.2.2节中讨论这项技术。

#### REST 的好处和弊端

REST有如下好处：

- 它非常简单，并且大家都很熟悉。
- 可以使用浏览器扩展（比如 Postman 插件）或者 curl 之类的命令行（假设使用的是 JSON 或其他文本格式）来测试 HTTP API。
- 直接支持请求/响应方式的通信。
- HTTP 对防火墙友好。
- 不需要中间代理，简化了系统结构。

它也存在一些弊端：

- 它只支持请求/响应方式的通信。
- 可能导致可用性降低。由于客户端和服务直接通信而没有代理来缓冲消息，因此它们必须在 REST API 调用期间都保持在线。
- 客户端必须知道服务实例的位置（URL）。如3.2.4节所述，这是现代应用程序中的一个重要问题。客户端必须使用所谓的**服务发现机制**来定位服务实例。
- 在单个请求中获取多个资源具有挑战性。
- 有时很难将多个更新操作映射到 HTTP 动词。

### 3.2.2 使用gRPC

如上一节所述，使用 REST 的一个挑战是，由于 HTTP 仅提供有限数量的动词，因此设计支持多个更新操作的 REST API 并不总是很容易。避免此问题的进程间通信技术是 gRPC，这是一个用于编写跨语言客户端和服务端的框架。gRPC 是一种基于二进制消息的协议，你不得不采用 API 优先的方法来进行服务设计。你可以使用基于 Protocol Buffer 的 IDL 定义 gRPC API，这是谷歌公司用于序列化结构化数据的一套语言中立机制。

gRPC API 由一个或多个服务和请求/响应消息定义组成。**服务定义**类似于 Java 接口，是强类型方法的集合。除了支持简单的请求/响应 RPC 之外，gRPC 还支持流式 RPC。服务器可以使用消息流回复客户端。客户端也可以向服务器发送消息流。

gRPC 使用 Protocol Buffers 作为消息格式。

gRPC 有几个好处：

- 设计具有复杂更新操作的API非常简单。
- 它具有高效、紧凑的进程间通信机制，尤其是在交换大量消息时。
- 支持在远程过程调用和信息传递过程中使用双向流式消息方式。
- 它实现了客户端和用各种语言编写的服务端之间的互操作性。

gRPC 也有几个弊端：

- 与基于 REST/JSON 的 API 机制相比，JavaScript 客户端使用基于 gRPC 的 API 需要做更多的工作。
- 旧式防火墙可能不支持 HTTP/2。

gRPC 是 REST 的一个引人注目的替代品，但与 REST 一样，它是一种同步通信机制，因此它也存在局部故障的问题。

### 3.2.3 使用断路器模式处理局部故障

分布式系统中，当服务试图向另一个服务发送同步请求时，永远都面临着局部故障的风险。因为客户端和服务端是独立的进程，服务端很有可能无法在有限的时间内对客户端的请求做出响应。服务端可能因为故障或维护的原因而暂停。或者，服务端也可能因为过载而对请求的响应变得极其缓慢。

客户端等待响应而被阻塞，这可能带来的麻烦是在其他客户端甚至使用服务的第三方应用之间传导，并导致服务中断。

要通过合理地设计服务来防止在整个应用程序中故障的传导和扩散，这是至关重要的。解决这个问题分为两部分：

- 必须让远程过程调用代理有正确处理无响应服务的能力。
- 需要决定如何从失败的远程服务中恢复。

#### 开发可靠的远程过程调用代理

每当一个服务同步调用另一个服务时，它应该使用 Netflix 描述的方法来保护自己。这种方法包括以下机制的组合。

- **网络超时**：在等待针对请求的响应时，一定不要做成无限阻塞，而是要设定一个超时。使用超时可以保证不会一直在无响应的请求上浪费资源。
- **限制客户端向服务器发出请求的数量**：把客户端能够向特定服务发起的请求设置一个上限，如果请求达到了这样的上限，很有可能发起更多的请求也无济于事，这时就应该让请求立刻失败。
- **断路器模式**：监控客户端发出请求的成功和失败数量，如果失败的比例超过一定的阈值，就启动断路器，让后续的调用立刻失效。如果大量的请求都以失败而告终，这说明被调服务不可用，这样即使发起更多的调用也是无济于事。在经过一定的时间后，客户端应该继续尝试，如果调用成功，则解除断路器。

Netflix Hystrix 是一个实现这些和其他模式的开源库。Polly 库在 .NET 社区中很受欢迎。

#### 从服务失效故障中恢复

使用诸如 Hystrix 之类的库只是解决方案的一部分。你还必须根据具体情况决定如何从无响应的远程服务中恢复你的服务。一种选择是服务只是向其客户端返回错误。

在其他情况下，返回备用值（fallback value，例如默认值或缓存响应）可能会有意义。

### 3.2.4 使用服务发现

服务实例具有动态分配的网络位置。此外，由于自动扩展、故障和升级，服务实例集会动态更改。因此，你的客户端代码必须使用服务发现。

#### 什么是服务发现

实现服务发现有以下两种主要方式：

- 服务及其客户直接与服务注册表交互。
- 通过部署基础设施来处理服务发现。（我将在第 12 章中详细讨论这一点。）

#### 应用层服务发现模式

实现服务发现的一种方法是应用程序的服务及其客户端与服务注册表进行交互。服务实例使用服务注册表注册其网络位置。客户端首先通过查询服务注册表获取服务实例来调用服务，然后它向其中一个实例发送请求。

这种服务发现方法是两种模式的组合。

第一种模式是自注册模式。服务实例调用服务注册表的注册API来注册其网络位置。它还可以提供运行状态检查 URL，在第 11 章中有更详细的描述。**运行状态检查** URL 是一个 API 端点，服务注册表会定期调用该端点来验证服务实例是否正常且可用于处理请求。服务注册表还可能要求服务实例调用“心跳” API 以防止其注册过期。

> **模式：自注册**
>
> 服务实例向服务注册表注册自己。

第二种模式是客户端发现模式。当客户端想要调用服务时，它会查询服务注册表以获取服务实例的列表。为了提高性能，客户端可能会缓存服务实例。然后，客户端使用负载平衡算法（例如循环或随机）来选择服务实例。然后它向选择的服务实例发出请求。

> **模式：客户端发现**
>
> 客户端从服务注册表检索可用服务实例的列表，并在它们之间进行负载平衡。

Netflix 和 Pivotal 在应用层服务发现方面做了大量普及工作。Netflix 开发并开源了几个组件，包括：Eureka，这是一个高可用的服务注册表；Eureka Java 客户端；Ribbon，这是一个支持Eureka客户端的复杂HTTP客户端。Pivotal 开发了 Spring Cloud，这是一个基于 Spring 的框架，使得 Netflix 组件的使用非常简单。基于 Spring Cloud 的服务自动向 Eureka 注册，基于 Spring Cloud 的客户端因此可以自动使用 Eureka 进行服务发现。

应用层服务发现的一个好处是它可以处理多平台部署的问题（服务发现机制与具体的部署平台无关）。

应用层服务发现的一个弊端是：你需要为你使用的每种编程语言（可能还有框架）提高服务发现库。Spring Cloud 只能帮助 Spring 开发人员。如果你正在使用其他 Java 框架或非 JVM 语言（如 Node.js 或 GoLang），则必须找到其他一些服务发现框架。

应用层服务发现的另一个弊端是开发者负责设置和管理服务注册表，这会分散一定的精力。因此，最好使用部署基础设施提供的服务发现机制。

#### 平台层服务发现模式

在第12章中，你将了解许多现代部署平台（如 Docker 和 Kubernetes）都具有内置的服务注册表和服务发现机制。部署平台为每个服务提供 DNS 名称、虚拟 IP（VIP）地址和解析为 VIP 地址的 DNS 名称。客户端向 DNS 名称和 VIP 发出请求，部署平台自动将请求路由到其中一个可用服务实例。因此，服务注册、服务发现和请求路由完全由部署平台处理。

部署平台包括一个服务注册表，用于跟踪已部署服务的 IP 地址。

这种方法是以下两种模式的组合：

- **第三方注册模式**：由第三方负责（称为**注册服务器**，通常是部署平台的一部分）处理注册，而不是服务本身向服务注册表注册自己。
- **服务端发现模式**：客户端不再需要查询服务注册表，而是向DNS名称发出请求，对该DNS名称的请求被解析到路由器，路由器查询服务注册表并对请求进行负载均衡。

> **模式：第三方注册**
>
> 服务实例由第三方自动注册到服务注册表。
>
> **模式：服务端发现**
>
> 客户端向路由器发出请求，路由器负责服务发现。

由平台提供服务发现机制的主要好处是服务发现的所有方面都完全由部署平台处理。服务和客户端都不包含任何服务发现代码。因此，无论使用哪种语言或框架，服务发现机制都可供所有服务和客户使用。

平台提供服务发现机制的一个弊端是它仅限于支持使用该平台部署的服务。例如，如前所述，在描述应用程序级别发现时，基于 Kubernetes 的发现仅适用于在 Kubernetes 上运行的服务。尽管存在此限制，我建议尽可能使用平台提供的服务发现。

## 3.3 基于异步消息模式的通信

使用消息机制时，服务之间的通信采用异步交换信息的方式完成。基于消息机制的应用程序通常使用**消息代理**，它充当服务之间的中介。另一种选择是使用无代理架构，通过直接向服务发送消息来执行服务请求。服务客户端通过向服务发送消息来发出请求。如果希望服务实例回复，服务将通过向客户端发送单独的消息的方式来实现。由于通信是异步的，因此客户端不会堵塞和等待回复。相反，客户端都假定回复不会马上就收到。

> **模式：消息**
>
> 客户端使用异步消息调用服务。

### 3.3.1 什么是消息传递

Gregor Hohpe 和 Bobby Woolf 在《Enterprise Integration Patterns》一书中定义了一种有用的消息传递模型。在此模型中，消息通过消息通道进行交换。发送方（应用程序或服务）将消息写入通道，接收方（应用程序或服务）从通道读取消息。

#### 关于消息

消息由消息头部和消息主体组成。**标题**是名称与值对的集合，描述正在发送的数据的元数据。除了消息发送者提供的名称与值对之外，消息头部还包含其他信息，例如发件人或消息传递基础设施生成的**唯一消息 ID**，以及可选的**返回地址**，该地址指定发送回复的消息通道。消息**正文**是以文本或二进制格式发送的数据。

有以下几种不同类型的消息。

- **文档**：仅包含数据的通用信息。接收者决定如何解释它。对命令式消息的回复是文档消息的一种使用场景。
- **命令**：一条等同于 RPC 请求的消息。它指定要调用的操作及其参数。
- **事件**：表示发送方这一端发生了重要的事件。事件通常是领域事件，表示领域对象的状态更改。

在本书描述的微服务架构实践中大量使用了命令式消息和事件式消息。

#### 关于消息通道

消息通过消息通道进行交换。发送方中的业务逻辑调用**发送端**接口，该接口封装底层通信机制。**发送端**由**消息发送**适配器类实现，该消息发送适配器类通过消息通道向接受器发送消息。**消息通道**是消息传递基础设施的抽象。调用接收器中的**消息处理程序**适配器类来处理消息。它调用接收方业务逻辑实现的**接收端接口**。任意数量的发送方都可以向通道发送消息。类似地，任意数量的接收方都可以从通道接收消息。

有以下两种类型的消息通道：点对点和发布-订阅。

- **点对点通道**向正在从通道读取的一个消息者传递消息。服务使用点对点通道来实现前面描述的一对一交互方式。例如，命令式消息通常通过点对点通道发送。
- **发布-订阅**通道将一条消息发给所有订阅的接收方。服务使用发布-订阅通道来实现前面描述的一对多交互方式。例如，事件式消息通常通过发布-订阅通道发送。

### 3.3.2 使用消息机制实现交互方式

消息机制的一个有价值的特性是它足够灵活，可以支持3.1.1节描述的所有交互方式。一些交互方式通过消息机制直接实现。其他必须在消息机制之上实现。

#### 实现请求/响应和异步请求/响应

当客户端和服务使用请求 / 响应 或 异步请求 / 响应 进行交互时，客户端会发送请求，服务会发回回复。

两种交互方式之间的区别在于，对于请求 / 响应，客户端期望服务立即响应，而对于异步请求 / 响应，则没有这样的期望。消息机制本质上是异步的，因此只提供异步请求 / 响应。但客户端可能会堵塞，直到收到回复。

客户端和服务端通过交换一对消息来实现异步请求 / 响应方式的交互。客户端发送命令式消息，该消息指定要对服务执行的操作和参数，这些内容通过服务拥有的点对点消息通道传递。该服务处理请求，并将包含结果的回复消息发送到客户端拥有的点对点通道。

客户端必须告知服务发送回复消息的位置，并且必须将回复消息与请求匹配。幸运的是，解决这两个问题并不困难。客户端发送具有**回复通道**头部的命令式消息。服务器将回复消息写入回复通道，该回复消息包含与**消息标识符**具有相同值的**相关性 ID**。客户端使用**相关性 ID** 将回复消息与请求进行匹配。

#### 实现单向通知

使用异步消息实现单向通知非常简单。客户端将消息（通常是命令式消息）发送到服务所拥有的点对点通道。服务订阅该通道并处理该消息，但是服务不会发回回复。

#### 实现发布/订阅

消息机制内置了对发布 / 订阅交互方式的支持。客户端将消息发布到由多个接收方读取的发布 / 订阅通道。

#### 实现发布/异步响应

发布 / 异步响应交互方式是一种更高级别的交互方式，它通过把发布 / 订阅和请求 / 响应这两种方式的元素组合在一起实现。客户端发布一条消息，在消息的头部中指定**回复通道**，这个通道同时也是一个发布 - 订阅通道。消费者将包含**相关性 ID** 的回复消息写入回复通道。客户端通过使用**相关性 ID** 来收集响应，以此将回复消息与请求进行匹配。

### 3.3.3 为基于消息机制的服务API创建API规范

服务的异步 API 规范必须指定消息通道的名称、通过每个通道交换的消息类型及其格式。并没有广泛采用的标准来记录通道和消息类型，你需要自己编写这样的文档。

#### 记录异步操作

可以使用以下两种不同交互方式之一调用服务的操作：

- **请求 / 异步响应式 API**
- **单向通知式 API**

#### 记录事件发布

服务还可以使用发布 / 订阅的方式对外发布事件。

### 3.3.4 使用消息代理

基于消息传递的应用程序通常使用**消息代理**，即服务通信的基础设施服务。

#### 无代理消息

在无代理的架构中，服务可以直接交换消息。ZeroMQ 是一种流行的无代理消息技术。

无代理的架构有以下一些好处：

- 运行更轻的网络流量和更低的延迟，因为消息直接从发送方发送到接收方，而不必从发送方到消息代理，再从代理转发到接收方。
- 消除了消息代理可能成为性能瓶颈或单点故障的可能性。
- 具有较低的操作复杂性，因为不需要设置的维护消息代理。

尽管这些好处看起来很吸引人，但无代理的消息具有以下明显的弊端：

- 服务需要了解彼此的位置，因此必须使用 3.2.4 节中描述的服务发现机制。
- 会导致可用性降低，因为在交换消息时，消息的发送方和接收方都必须同时在线。
- 在实现例如确保消息能够成功投递这些复杂功能时的挑战性更大。

#### 基于代理的消息

消息代理是所有消息的中介节点。发送方将消息写入消息代理，消息代理将消息发送给接收方。

使用消息代理的一个重要好处是发送方不需要知道接收方的网络位置。另一个好处是消息代理缓存消息，直到接收方能够处理它们。

流行的开源消息代理包括：

- Apache ActiveMQ
- RabbitMQ
- Apache Kafka

还有基于云的消息服务，例如 AWS kinesis 和 AWS SQS。

选择消息代理时，你需要考虑以下各种因素：

- **支持的编程语言**：你选择的消息代理应该支持尽可能多的编程语言。
- **支持的消息标准**：消息代理是否支持多种消息标准，比如AMQP和STOMP，还是它仅支持专用的消息标准？
- **消息排序**：消息代理是否能够保留消息的排序？
- **投递保证**：消息代理提供什么样的消息投递保证？
- **持久性**：消息是否持久化保存到磁盘并且能够在代理崩溃时恢复？
- **耐久性**：如果接收方重新连接到消息代理，它是否会收到断开连接时发送的消息？
- **可扩展性**：消息代理的可扩展性如何？
- **延迟**：端到端是否有较大延迟？
- **竞争性（并发）接收方**：消息代理是否支持竞争性接收方？

#### 使用消息代理实现消息通道

每个消息代理都用自己与众不同的概念来实现消息通道。如表3-2所示，ActiveMQ等JMS消息代理具有队列和主题。基于AMQP的消息代理（如RabbitMQ）具有交换和队列。Apache Kafka有主题，AWS Kinesis有流，AWS SQS有队列。更重要的是，一些消息代理提供了比本章中描述的信息和通道更灵活的消息机制。

| 消息代理                   | 点对点通道 | 发布-订阅通道            |
| -------------------------- | ---------- | ------------------------ |
| JMS                        | 队列       | 主题                     |
| Apache Kafka               | 主题       | 主题                     |
| 基于AMQP的代理，如RabbitMQ | 交换+队列  | 组播式交换和每客户端队列 |
| AWS Kinesis                | 流         | 流                       |
| AWS SQS                    | 队列       | /                        |

这里描述的几乎所有消息代理都支持点对点和发布-订阅通道。唯一的例外是AWS SQS，它仅支持点对点通道。

#### 基于代理的消息的好处和弊端

使用消息有以下很多好处。

- **松耦合**：客户端发起请求时只要发送给特定的通道即可，客户端完全不需要感知服务实例的情况，客户端不需要使用服务发现机制去获得服务实例的网络位置。
- **消息缓存**：消息代理可以在消息被处理之前一直缓存消息。像HTTP这样的同步请求/响应协议，在交换数据时，发送方和接收方必须同时在线。然而，在使用消息机制的情况下，消息会在队列中缓存，直到它们被接收方处理。
- **灵活的通信**：消息机制支持前面提到的所有交互方式。
- **明确的进程间通信**：基于RPC的机制总是企图让远程服务调用跟本地调用看上去没有什么区别（在客户端和服务端同时使用远程调用代理）。然而，因为物理定律（如服务器不可预计的硬件失败）和可能的局部故障，远程和本地调用还是大相径庭的。消息机制让这些差异变得很明确，这样程序员不会陷入一种“太平盛世”的错觉。

然而，消息机制也有如下一些弊端。

- **潜在的性能瓶颈**：消息代理可能存在性能瓶颈。幸运的是，许多现代消息代理都支持高度的横向扩展。
- **潜在的单点故障**：消息代理的高可用性至关重要，否则系统整体的可靠性将受到影响。幸运的是，大多数现代消息代理都是高可用的。
- **额外的操作复杂性**：消息系统是一个必须独立安装、配置和运维的系统组件。

### 3.3.5 处理并发和消息顺序

基于消息的架构挑战之一是如何在保留消息顺序的同时，横向扩展多个接收方的实例。而且，即使单个服务实例也可能使用线程来同时处理多个消息。同时处理消息的挑战是确保每个消息只被处理一次，并且是按照它们发送的顺序来处理的。

现代消息代理（如 Apache Kafka 和 AWS Kinesis）使用的常见解决方案是使用**分片**（分区）通道。该解决方案分为三个部分：

1. 分片通道由两个或多个分片组成，每个分片的行为类似于一个通道。
2. 发送方在消息头部指定分片键，通常是任意字符串或字节序列。消息代理使用分片键将消息分配给特定的分片。例如，它可以通过计算分片键的散列来选择分片。
3. 消息代理将接收方的多个实例组合在一起，并将它们视为相同的逻辑接收方。例如，Apache Kafka 使用术语**消费者组**。消息代理将每个分片分配给单个接收器。它在接收方启动和关闭时重写分配分片。

### 3.3.6 处理重复消息

使用消息机制时必须解决的另一个挑战是处理重复消息。理想情况下，消息代理应该只传递一次消息，但保证有且仅有一次的消息传递通常成本很高。相反，大多数消息代理承诺**至少**成功传递一次消息。

处理重复消息有以下两种不同的方法：

- 编写幂等消息处理程序。
- 跟踪消息并丢弃重复项。

#### 编写幂等消息处理器

如果应用程序处理消息的逻辑是满足幂等的，那么重复的消息就是无害的。所谓应用程序的**幂等性**，是指即使这个应用被相同输入参数多次重复调用时，也不会产生额外的效果。

#### 跟踪消息并丢弃重复项

一个简单的解决方案是消息接收方使用消息 id 跟踪它已处理的消息并丢弃任何重复项。

另一个选项是消息处理程序在应用程序表，而不是专用表中记录消息 id。

### 3.3.7 事务性消息

服务通常需要在更新数据库的事务中发布消息。数据库更新和消息发送都必须在事务中进行。否则，服务可能会更新数据库，然后在发送消息之前崩溃。如果服务不以原子方式执行这两个操作，则类似的故障可能使系统处于不一致状态。

传统的解决办法是在数据库和消息代理之间使用分布式事务。然而，在第 4 章中你会了解到，分布式事务对现今的应用程序而言并不是一个很好的选择。而且，很多新的消息代理，例如 Apache Kafka 并不支持分布式事务。

#### 使用数据库表作为消息队列

可靠地发布消息的直接方法是应用事务性发件箱模式。此模式使用数据库表作为临时消息队列。

> **模式：事务性发件箱**
>
> 通过将事件或消息保存在数据库的 OUTBOX 表中，将其作为数据库事务的一部分发布。

你可以对某些 NoSQL 数据库使用类似的方法。

挑战在于有效地找到那些拥有事件并发布事件的业务实体。



将消息从数据库移动到消息代理并对外发送有两种不同的方法。

#### 通过轮询模式发布事件

如果应用程序使用关系型数据库，则对外发布插入 OUTBOX 表的消息的一种非常简单的方法是让 `MessageRelay` 在表中轮询未发布的消息。

接下来，`MessageRelay` 把这些消息发送给消息代理，它把每个消息发送给它们的目标消息通道。最后，`MessageRelay` 把完成发送的消息从 OUTBOX 表中删除。

> **模式：轮询发布数据**
>
> 通过轮询数据库中的发件箱来发布消息。

轮询数据库是一种在小规模下运行良好的简单方法。其弊端是经常轮询数据库可能造成昂贵的开销（导致数据库性能下降）。此外，你是否可以将此方法与 NoSQL 数据库一起使用取决于 NoSQL 数据库支持的查询功能。

#### 使用事务日志拖尾模式发布事件

更加复杂的实现方式，是让 `MessageRelay` **拖尾**数据库的事务日志文件（也称为提交日志）。每次应用程序提交到数据库的更新都对应着数据库事务日志中的一个条目。事务日志挖掘器可以读取事务日志，把每条跟消息有关的记录发送给消息代理。

> **模式：事务日志拖尾**
>
> 通过拖尾事务日志发布对数据库所做的更改。

这个方案有一些实际的应用案例和实践可供参考：

- **Debezium**：一个开源项目，它可以向 Apache Kafka 消息代理发布数据库修改。
- **LinkedIn Databus**：一个开源项目，用于挖掘 Oracle 事务日志文件并将更改发布为事件。LinkedIn 使用 Databus 将各种派生数据存储与记录系统同步。
- **DynamoDB streams**：包含过去 24 小时内的 DynamoDB 表更改（创建、更新和删除）的序列，并且这个序列是按时间排序的。应用程序可以从流中读取这些更改，例如，将它们作为事件发布。
- **Eventuate Tram**：这是我自己的开源事务消息库，它使用 MySQL binlog 协议、Postgres WAL 或轮询来读取对 OUTBOX 表所做的更改并将它们发布到 Apache Kafka。

### 3.3.8 消息相关的类库和框架

服务需要使用库来发送和接收消息。一种方法是使用消息代理的客户端库，但是直接使用这样的库有几个问题：

- 客户端库将发布消息的业务逻辑耦合到消息代理 API。
- 消息代理的客户端库通常是非常底层的，需要多行代码才能发送或接收消息。
- 客户端库通常只能提供发送和接收消息的基本机制，不支持更高级别的交互方式。

更好的方法是使用更高级别的库或框架来隐藏底层的细节，并直接支持更高级别的交互方式。

## 3.4 使用异步消息提高可用性

### 3.4.1 同步消息会降低可用性

REST 是一种非常流行的进程间通信机制。REST 的问题在于它是一个同步协议：HTTP 客户端必须等待服务端返回响应。只要服务使用同步协议进行通信，就可能降低应用程序的可用性。

这个问题不仅仅跟基于 REST 的通信有关。当服务必须从另一个服务获取信息后，才能够返回它客户端的调用，这种情况都会导致可用性问题。即使服务使用异步消息请求 / 响应方式的交互进行通信，也存在此问题。

如果你想最大化一个系统的可用性，就应该设法最小化系统的同步操作量。

### 3.4.2 消除同步交互

在必须处理同步请求的情况下，仍然有一些方式可以最大限度地降低同步通信的数量。

#### 使用异步交互方式

理想情况下，所有的交互都应该使用本章之前所描述的异步交互。

客户端和服务端使用消息通道发送消息来实现异步通信。这个交互过程中不存在堵塞等待响应的情况。

这样的架构非常有弹性，因为消息代理会一直缓存消息，直到有服务端接收并处理消息。

然而，问题是服务很多情况下都采用类似 REST 这样的同步通信协议的外部API，并且要求对请求立即做出响应。在这种情况下，我们可以采用复制数据的方式来提高可用性。

#### 复制数据

在请求处理环节中减少同步请求的另外一种方法，就是进行数据复制。服务维护一个数据副本，这些数据是服务在处理请求时需要使用的。这些数据的源头会在数据变化时发出消息，服务订阅这些消息来确保数据副本的实时更新。

然而，复制数据的一个弊端在于，有时候被复制的数据量巨大，会导致效率低下。复制的另一个弊端在于，复制数据并没有从根本上解决服务如何更新其他服务所拥有的数据这个问题。

解决该问题的一种方法是让服务暂缓与其他服务交互，直到它给客户端发送了响应。

#### 先返回响应，再完成处理

另外一种在请求处理环节消除同步通信的办法如下：

1. 仅使用本地的数据来完成请求的验证。
2. 更新数据库，包括向 OUTBOX 表插入消息。
3. 向客户端返回响应。

当处理请求时，服务并不需要与其他服务直接进行同步交互。取而代之的是，服务异步向其他的服务发送消息。这种方式确保了服务之间的松耦合。

在完全处理请求之前响应服务的弊端是它使客户端更复杂。

# 第4章 使用 Saga 管理事务

# 第7章 在微服务架构中实现查询

在微服务架构中编写查询非常具有挑战性。查询通常需要检索分散在多个服务所拥有的数据库中数据。但是，你不能使用传统的分布式查询处理机制，因为即使技术上可行，它也会打破服务之间的隔离和封装。

在微服务架构中实现查询操作有两种不同的模式：

- **API 组合模式**：这是最简单的方法，应尽可能使用。它的工作原理是让拥有数据的服务的客户端负责调用服务，并组合服务返回的查询结果。
- **命令查询职责隔离（CQRS）模式**：它比 API 组合模式更强大，但也更复杂。它维护一个或多个视图数据库，其唯一目的是支持查询。

## 7.1 使用 API 组合模式进行查询

在本节中，我将描述 `findOrder()` 查询操作，它是从多个服务获取数据的查询方法。

### 7.1.1 findOrder() 查询操作

`findOrder()` 操作通过主键检索订单。它将 `orderId` 作为参数并返回 `OrderDetails` 对象，该对象包含有关订单的信息。此操作由实现**订单状态视图**（Order Status View）的前端模块（如移动设备或 Web 应用程序）调用。

由于单体应用的数据驻留在单个数据库中，因此可以通过执行连接（join）各个表的单个 SELECT 语句轻松检索订单详细信息。相比之下，基于微服务的应用程序版本中，数据分散在多个服务中。任何需要订单详细信息的客户端都必须从所有这些服务获取数据。

### 7.1.2 什么是 API 组合模式

这个模式通过调用拥有数据的服务并组合结果来实现查询操作。它有两种类型的参与者：

- **API 组合器**：它通过查询数据提供方的服务来实现查询操作。
- **数据提供方服务**：拥有查询返回的部分数据的服务。

> **模式：API 组合**
>
> 通过查询每个服务的 API 并组合结果，实现从多个服务检索数据的查询。

是否可以使用此模式实现特定查询操作取决于几个因素，包括数据的分区方式、拥有数据的服务公开的 API 的功能，以及服务使用数据库的功能，等等。例如，即使**提供方服务**拥有用于检索所需数据的 API，聚合器也可能需要执行大量数据集的低效内存连接。

### 7.1.3 使用 API 组合模式实现 findOrder() 查询操作

`findOrder()` 查询操作相当于一个简单的基于主键的 equi-join 查询。可以假设每个**提供方服务**都有一个 API 接口，用于通过 orderId 检索所需的数据。因此，采用 API 组合模式来实现 `findOrder()` 查询操作似乎是合情合理的。

在这个例子中，**API 组合器**是一种将查询公开为 REST 接口的服务。**提供方服务**还实现了 REST API。但是，如果服务使用其他进程间通信协议，例如 gRPC 而不是 HTTP，则概念是相同的。

### 7.1.4 API 组合模式的设计缺陷

使用此模式时，你必须解决两个设计问题：

- 确定架构中的哪个组件是查询操作的 **API 组合器**。
- 如何编写有效的聚合逻辑。

#### 由谁来担任 API 组合器的角色

- 第一个选择，是由服务的客户端扮演 **API 组合器**的角色。
  对于防火墙之外的客户以及通过较慢网络访问的服务，此选择可能不实用。
- 第二个选择，由实现应用程序外部 API 的 API Gateway 来扮演 API 组合器的角色，用来完成查询操作和查询结果的组合。
  如果查询操作是应用程序外部 API 的一部分，则此选择有意义。API Gateway 不是将请求路由到另一个服务，而是实现 API 组合逻辑。这种方法使得防火墙外运行的客户端（例如移动设备）能够通过单个 API 调用有效地从众多服务中检索数据。
- 第三个选择是将 **API 组合器**实现为独立的服务。
  此选择可以用于由多个服务在内部使用的查询操作。此操作还可用于外部可访问的查询操作，由于它们的聚合逻辑过于复杂，因此无法在 API Gateway 中完成查询，必须使用单独的服务。

#### API 组合器应该使用响应式编程模型

在开发分布式系统时，我们一直努力降低服务之间的延迟。**API 组合器**应尽可能地并行调用提供方服务，最大限度地缩短查询操作的响应时间。但有时，**API 组合器**需要一个**提供方服务**的结果才能调用另一个服务。在这种情况下，它需要按顺序调用一部分（但希望不是全部）**提供方服务**。

高效执行顺序和并行服务调用混合的逻辑可能很复杂。为了使 **API 组合器**达到较高的可维护性、性能和可扩展性，它应该使用基于 Java `CompletableFuture`、RxJava 可观测或其他类似的响应式设计。我将在第 8 章讲 API Gateway 模式的时候再深入讨论这个主题。

### 7.1.5 API 组合模式的好处和弊端

此模式是在微服务架构中实现查询操作的简单直观方式。但它也有一些缺点：

- 增加了额外的开销。
- 带来了可用性降低的风险。
- 缺乏事务数据一致性。

我们来逐一分析。

#### 增加了额外的开销

这种模式的一个缺点是它需要调用多个服务和查询多个数据库，这带来了额外的开销。在单体应用程序中，客户端可以使用单个请求检索数据，这通常会执行单个数据库查询。相比之下，使用 API 组合模式会涉及多个请求和多个数据库查询。因此，它需要更多计算和网络资源，运行应用程序的成本也相应增加。

#### 带来可用性降低的风险

这种模式的另一个缺点是导致可用性降低。操作的可用性随着所涉及的服务数量而下降。因为查询操作的实现涉及至少三个服务：**API 组合器**和至少两个提供方服务，其可用性将显著小于单个服务的可用性。

你可以使用几种策略来提高可用性。一种策略是 **API 组合器**在**提供方服务**不可用时，返回先前缓存的数据。**API 组合器**有时会缓存**提供方服务**返回的数据，以提高性能。它还可以使用此缓存来提高可用性。如果提供方服务不可用，则 **API 组合器**可以从缓存中返回数据，尽管这些缓存数据可能是过时的。

另一种提高可用性的策略是让 **API 组合器**返回不完整的数据。

#### 缺乏事务数据一致性

API 组合模式的另一个缺点是缺乏数据一致性。单体应用程序通常使用一个数据库事务执行查询操作。ACID 事务受制于隔离级别的约束，可以确保应用程序具有一致的数据视图，即使它执行多个数据库查询。相反，API 组合模式则是针对多个数据库执行查询。这种方式存在一种风险，即查询操作将返回不一致的数据。

尽管存在这些缺点，API 组合模式还是非常有用的。你可以使用它来实现许多查询操作。但是有一些查询操作无法使用此模式有效实现。例如，查询操作可能需要 **API 组合器**执行大规模数据的内存连接。

## 7.2 使用 CQRS 模式

许多企业级应用程序使用关系型数据库作为数据记录的事务系统，并使用文本搜索数据库（如 Elasticsearch 或 Solr）进行文本搜索查询。某些应用程序可以通过同时写入来保持数据库同步。然后再定期将数据从关系型数据库复制到文本搜索引擎中。具有此架构的应用程序利用了多个数据库的优势：关系型数据库的事务属性和文本数据库的查询功能。

> **模式：命令查询职责隔离（CQRS）**
>
> 使用事件来维护从多个服务复制数据的只读视图，借此实现对来自多个服务的数据的查询。

CQRS 是这种架构的概括。它维护一个或多个视图数据库，而不仅仅是文本搜索数据库，进而实现一个或多个应用程序的查询。

### 7.2.1 为什么要使用 CQRS

让我们从使用 API 组合无法有效实现的多服务查询开始。

#### 实现 findOrderHistory() 查询操作

`findOrderHistory()` 操作可以检索消费者的订单历史记录。它有几个参数：

- `consumerId`：用于识别消费者。
- `pagination`：用于分页显式返回结果。
- `filter`：过滤条件，包括要退货的订单的最大期限、可选的订单状态以及与餐馆名称和菜单项匹配等可选关键字。

此查询操作返回一个 `OrderHistory` 对象，该对象包含时间递增排序的订单摘要。

从表面上看，此操作类似于 `findOrder()` 查询操作。唯一的区别是它返回多个订单而不是一个。看起来 **API 组合器**只需针对每个**提供方服务**执行相同的查询并组合结果。不幸的是，它并不那么简单。因为并非所有服务都存储用于过滤或排序的属性。

**API 组合器**有两种方法可以解决此问题。一种解决方案是让**API 组合器**进行内存中连接。

这种方法的缺点是它可能需要 **API 组合器**来检索和连接大规模的数据集，相当低效。

另一个解决方案是让 **API 组合器**从 Order Service 和 Kitchen Service 检索匹配的订单，然后通过 ID 从其他服务请求订单。但是，只有这些服务具有支持批量查询的 API 时，这才是实用的。由于网络流量过大，单独请求订单可能效率低下。

诸如 `findOrderHistory()` 之类的查询要求 **API 组合器**在某种程度上实现关系型数据库查询执行引擎的功能。一方面，这可能会将查询工作从可扩展性较低的数据库转移到可扩展性较高的应用程序。另一方面，这样做效率很低。此外，开发人员应该编写业务功能，而不是实现一个查询执行引擎。

接下来，我将展示如何应用 CQRS 模式并使用单独的数据存储区，该数据存储区旨在有效地实现 `findOrderHistory()` 查询操作。

#### 单一服务查询的挑战：findAvailableRestaurants()

正如你刚才所见，实现从多个服务检索数据的查询可能具有挑战性。但即使是单个服务的本地查询其实也很难实现。有几个可能的原因。一种情况是，如这里所讨论的，拥有数据的服务不适合实现查询。另一个原因是有时服务的数据库（或数据模型）不能有效支持查询。

例如，考虑 `findAvailableRestaurants()` 查询操作。此查询查找在给定时间可送餐到客户地址的餐馆。它的核心是在地理空间（基于位置）搜索位于客户地址一定距离内的餐馆。

实现此查询操作的关键挑战是执行有效的地理空间查询。如何实现 `findAvailableRestaurants()` 查询取决于存储餐馆的数据库的功能。例如，使用 MongoDB 或 Postgres 和 MySQL 地理空间扩展实现 `findAvailableRestaurants()` 查询很简单。这些数据库支持地理空间数据类型和针对这些类型的索引及查询。

如果应用程序将餐馆存储在其他类型的数据库中，实现 `findAvailableRestaurants()` 查询将更具挑战性。它必须以一种旨在支持地理空间查询的形式保存餐馆数据的副本。例如，该应用程序可以使用 DynamoDB 的地理空间索引库，该库使用表作为地理空间索引。或者应用程序可以将餐馆数据的副本存储在完全不同类型的数据库中，这种情况与使用文本搜索数据库进行文本查询非常相似。

使用副本的挑战是在原始数据发生变化时使其保持最新状态。

#### 隔离问题的必要性

单个服务查询难以实现的另一个原因是，拥有数据的服务有时不是实现查询的服务。

数据所有权并不是决定哪个服务实现查询操作的唯一要考虑的因素。你还必须考虑到隔离问题的必要性，并避免过多的职责导致过载服务。

### 7.2.2 什么是 CQRS

7.2.1 节中描述的例子强调了在微服务架构中实现查询时经常会遇到的三个问题：

- 使用 API 组合模式检索分散在多个服务中的数据会导致昂贵、低效的内存中连接。
- 拥有数据的服务将数据存储在不能有效支持所需查询的表单或数据库中。
- 隔离问题的考虑意味着，拥有数据的服务不一定是会实现查询操作的服务。

所有这三个问题的解决方案是使用 CQRS 模式。

#### CQRS 隔离命令和查询

CQRS 是命令查询职责隔离（Command Query Responsibility Segregation）的简称，顾名思义，它涉及**隔离**或问题的分隔。它将持久化数据模型和使用数据的模块分为两部分：命令端和查询端。命令端模块和数据模型实现构建、更新和删除操作（缩写为 CUD，例如：HTTP POST、PUT 和 DELETE）。查询端模块和数据模型实现查询（例如 HTTP GET）。查询端通过订阅命令端发布的事件，使其数据模型与命令端数据模型保持同步。

服务的非 CQRS 和 CQRS 版本都包括由各种 CRUD 操作组成的 API。在基于非 CQRS 的服务中，这些操作通常由映射到数据库的领域模型实现。为了提高性能，一些查询可能会绕过领域模型并直接访问数据库。持久化数据模型同时支持命令端和查询端。

在基于 CQRS 的服务中，位于命令端的领域模型处理 CRUD 操作并映射到其自己的数据库。它还可以处理简单查询，例如不需要 join，仅是基于主键的查询。命令端在数据发生变化时发布领域事件。可以使用诸如 Eventuate Tram 之类的框架或使用事件溯源来发布这些事件。

独立的查询模型可以用来处理复杂的查询场景。查询端的代码往往比命令端简单很多，因为它不需要负责实现具体的业务逻辑。查询端可以使用的数据库种类很灵活，只要数据库能够支持需要的查询功能即可。查询端的事件处理程序会订阅领域事件并更新数据库。甚至可能存在多个查询模型，与需要的查询类型一一对应。

#### CQRS 和查询专用服务

CQRS 不仅可以在服务中应用，还可以使用此模式来定义查询服务。查询服务的 API 只包含查询操作，并无命令操作。它通过订阅由一个或多个其他服务发布的事件来确保它的数据是不断更新的，并由此实现查询操作。查询端服务订阅由多个服务发布的事件。这是实现查询用视图的好方法。这种视图（和它的数据）不属于任何特定服务，因此将其实现为独立的服务是合理的。

查询服务也是实现复制单个服务所拥有的数据的视图的好方法，这样我们可以把查询的实现和服务的功能分隔开。

在许多方面，CQRS 也代表了当前流行的基于事件的数据库应用场景，例如它使用关系型数据库作为记录系统，使用文本搜索引擎（如 Elasticsearch）来处理文本查询。不同之处在于 CQRS 使用更广泛的数据库类型，而不仅仅是文本搜索引擎。此外，通过订阅事件，近乎实时地更新 CQRS 查询端视图。

### 7.2.3 CQRS 的好处

CQRS 既有利也有弊。好处如下：

- 在微服务架构中高效地实现查询。
- 高效地实现多种不同的查询类型。
- 在基于事件溯源技术的应用程序中实现查询。
- 更进一步地实现问题隔离。

#### 在微服务架构中高效地实现查询

CQRS 模式的一个好处是它有效地实现了检索多个服务所拥有的数据的查询。如前所述，使用 API 组合模式实现查询有时会导致大规模数据集的昂贵、低效的内存中连接。对于那些查询，使用易于查询的 CQRS 视图更有效，该视图预加载（并预处理）来自两个或更多服务的数据。

#### 高效地实现多种不同的查询类型

CQRS 的另一个好处是它使应用程序或服务能够高效地实现各种查询。尝试使用单个持久化数据模型支持所有查询通常具有挑战性，并且在某些情况下是不可能的。一些 NoSQL 数据库具有非常有限的查询功能。即使数据库具有支持特定类型查询的扩展，使用专用数据库通常也更有效。CQRS 模式通过定义一个或多个视图来避免单个数据存储的限制，每个视图都有效地实现特定查询。

#### 在基于事件溯源技术的应用程序中实现查询

CQRS 还克服了事件溯源的主要限制。事件存储库仅支持基于主键的查询。CQRS 模式订阅由基于事件溯源的聚合发布的事件流，可以保持最新的聚合的一个或多个视图，由此解决此限制。这也是基于事件溯源的应用程序总是使用 CQRS 的原因。

#### 更进一步地实现问题隔离

CQRS 的另一个好处是它会隔离问题。领域模型及其相应的持久化数据模型不必同时处理命令的查询。CQRS 模式为服务的命令端和查询端定义了单独的代码模块和数据库模式。通过隔离问题，命令端和查询端可能更简单，更易于维护。

此外，CQRS 使实现查询的服务与拥有数据的服务不同。CQRS 查询服务提供订阅由拥有该数据的一个或多个服务发布的事件来维护视图。

### 7.2.4 CQRS 的弊端

尽管 CQRS 有不少好处，但它也有一些弊端：

- 更加复杂的架构。
- 处理数据复制导致的延迟。

#### 更加复杂的架构

CQRS 的一个缺点是它使复杂性增加了。开发人员必须编写更新和查询视图的查询端服务。管理和运维额外的数据存储库提高了运维的复杂性。此外，应用程序可能使用不同类型的数据库，这进一步增加了开发人员和运维人员面临的复杂性。

#### 处理数据复制导致的延迟

CQRS 的另一个缺点是处理命令端和查询端视图之间的“滞后”。更新聚合然后立即查询视图的客户端应用程序可能会看到聚合的先前版本。它必须避免用向用户暴露潜在的不一致性的方式编写 CQRS 的查询端。

一种解决方案是采用命令端和查询端 API 为客户端提供版本信息，使其能够判断查询端是否过时。客户端可以轮询查询端的视图，直到它是最新的。

用户界面（如移动应用程序或单页面 JavaScript 应用程序）可以通过在针对聚合的命令执行成功后，更新其本地版本的领域模型，而不必发出查询来克服复制可能带来的延迟。例如，它可以使用命令返回的数据更新其本地领域模型。当用户操作触发查询时，本地领域模型的数据视图将是最新的。这种方法的一个缺点是用户界面代码可能需要复制服务器端代码，只有这样才能保持对本地领域模型的不断更新。

## 7.3 设计 CQRS 视图

视图模块包含视图数据库和三个子模块（事件处理程序、查询 API、数据访问）。

数据访问模块实现数据库访问逻辑。事件处理程序和查询 API 模块使用数据访问模块来更新和查询数据库。事件处理程序模块订阅事件并更新数据库。查询 API 模块负责实现查询 API。

在开发视图模块时，你必须做出一些重要的设计决策：

- 你必须选择合适的底层数据库，并设计数据结构。
- 在设计数据访问模块时，你必须解决各种问题，包括确保更新是幂等的，并且能够处理并发更新。
- 在现有应用程序中实现新视图或更改现有应用程序的模式时，必须实现一种机制，以便有效地构建或重建视图。
- 你必须决定如何设计视图的客户端，以应对前面描述的复制延迟。

### 7.3.1 选择视图存储库

#### SQL 还是 NoSQL 数据库

**NoSQL 数据库**通常具有有限的事务模式和较少的查询功能。在一些情况下，NoSQL 数据库比 SQL 数据库更有优势，包括更灵活的数据模型以及更好的性能和可扩展性。

NoSQL 数据库通常是 CQRS 视图的一个很好的选择，CQRS 可以利用它们的优势并忽略其弱点。CQRS 视图受益于 NoSQL 数据库更丰富的数据模型和性能。它不受 NoSQL 数据库事务处理能力的限制，因为 CQRS 只需要使用简单的事务并执行一组固定的查询即可。

话虽如此，有时使用 SQL 数据库实现 CQRS 视图也是有意义的。在主流硬件上运行的现代关系型数据库具有出色的性能。通常，开发人员、数据库管理员和 IT 运维人员对 SQL 数据库比对 NoSQL 数据库更熟悉。如前所述，SQL 数据库通常具有非关系特征的扩展，例如地理空间数据类型和查询。此外，CQRS 视图可能需要使用 SQL 数据库才能支持报表引擎。

| 如果你需要               | 使用                                                         | 例如                                                      |
| ------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| 基于主键的 JSON 对象查找 | 文档型数据库，例如 MongoDB 或 DynamoDB，或者 Redis 这样的键值存储数据库 | 通过维护包含每个客户的 MongoDB 文档来实现订单历史记录     |
| 基于查询的 JSON 对象查找 | 文档型数据库，例如 MongoDB 或 DynamoDB                       | 使用 MongoDB 或 DynamoDB 实现客户视图                     |
| 文本查询                 | 文本搜索引擎，例如 Elasticsearch                             | 通过维护每个订单的 Elasticsearch 文档来实现订单的文本搜索 |
| 图查询                   | 图数据库，例如 Neo4j                                         | 通过维护客户、订单和其他数据的图标来实现欺诈检测          |
| 传统的 SQL 报表 / BI     | 关系型数据库                                                 | 标准业务报告和分析                                        |

#### 支持更新操作

除了有效地实现查询之外，视图数据模型还必须有效地实现事件处理程序执行的数据更新操作。事件处理程序通常使用其主键更新或删除视图数据库中的记录。

但有时，它需要使用类似外键的做法来更新或删除记录。

某些类型的数据库能够有效地支持基于外键的更新操作。例如，如果你使用的是关系型数据库或 MongoDB，则需要在必要的列上创建索引。但是使用其他 NoSQL 数据库时，不基于主键的更新并不那么容易。应用程序需要维护某种特定于数据库的映射，从外键到主键，以确定要更新的记录。例如，使用仅支持基于主键的更新和删除的 DynamoDB 的应用程序必须首先查询 DynamoDB 二级索引以确定要更新或删除的项的主键。

### 7.3.2 设计数据访问模块

事件处理程序和查询 API 模块不直接访问数据存储区。相反，他们使用数据访问模块，该模块由数据访问对象（DAO）及其辅助类组成。DAO 有几项职责。它实现由事件处理程序调用的更新操作，以及查询模块调用的查询操作。DAO 把上层代码映射到数据库 API 使用的数据类型。它还必须处理并发更新并确保更新是幂等的。

#### 并发处理

有时，DAO 必须处理对同一数据库记录进行多个并发更新的可能性。如果视图订阅由单个聚合类型发布的事件，则不会出现任何并发问题。因为特定的聚合实例发布的事件是按顺序处理的。因此，对应于聚合实例的记录不会同时更新。但是，如果视图订阅由多个聚合类型发布的事件，则多个事件处理程序可能同时更新同一记录。

DAO 必须以确保正确处理这种情况的方式编写。它不能允许一次更新覆盖另一次更新。如果 DAO 通过读取记录进行更新，然后再写入已更新记录的做法，则必须使用悲观锁或乐观锁。

#### 幂等事件处理程序

如第 3 章所述，可以多次使用同一事件调用事件处理程序。如果查询端事件处理程序是幂等的，这通常不是问题。如果多次处理重复事件，结果仍旧不会出错，则事件处理程序是幂等的。在最坏的情况下，视图数据存储将暂时过时。

如果不希望出现这种情况，则事件处理程序应检测并丢弃重复事件，像非幂等事件处理程序一样。

如果重复事件导致不正确的结果，则事件处理程序不是幂等的。例如，增加银行账户余额的事件处理程序不是幂等的。如第 3 章所述，非幂等事件处理程序必须通过记录它在视图数据存储中处理事件的 ID 来检测和丢弃重复事件。

为了确保可靠，事件处理程序必须记录事件 ID 并以原子化的方式更新数据存储区。如何执行此操作取决于数据库的类型。如果视图的底层数据库是 SQL 数据库，则事件处理程序可以将已处理的事件作为更新视图的一部分插入 `PROCESSED_EVENTS` 表中。但是，如果视图底层数据库是具有有限事务模型的 NoSQL 数据库，则事件处理程序必须将事件保存在它更新的数据存储区“记录”（例如，MongoDB 文档或 DynamoDB 表项）中。

请务必注意，事件处理程序不需要记录每个事件的 ID。如果与 Eventuate 的情况一样，事件具有单调递增的 ID，则每个记录仅需要存储从给定聚合实例接收的 `max(eventId)`。此外，如果记录对应于单个聚合实例，则事件处理程序仅需要记录 `max(eventId)`。只有表示来自多个聚合的事件连接的记录必须包含从 `[aggregate type, aggregate id]` 到 `max(eventId)` 的映射。

#### 让客户端应用程序采用最终一致性的视图

正如我之前所说，使用 CQRS 的一个问题是命令端更新后，立即执行查询的客户端可能看不到自己的更新。由于消息传递基础设施不可避免的延迟，视图是最终一致的。

命令和查询模块 API 可以使客户端使用以下方法检测不一致性。命令端操作将包含已发布事件的 ID 标记返回给客户端。然后，客户端把这个事件有关的 ID 传递给查询操作，如果该事件尚未更新视图，则返回查询错误。视图模块可以使用重复事件检测机制来实现这样的功能。

### 7.3.3 添加和更新 CQRS 视图

CQRS 视图将在应用程序的整个生命周期内被不断地添加和更新。

#### 使用归档事件构建 CQRS 视图

一个问题是消息代理无法无限期地存储消息。传统的消息代理如 RabbitMQ 会在消费者处理完消息后删除该消息。更为现代的消息代理，例如 Apache Kafka，在可配置的保留期内保存消息，但也不会无限期地存储事件。因此，只能通过从消息代理读取所有需要的事件来构建视图。相反，应用程序还必须读取已存档的旧事件，这些旧事件可能都已经被保存到了 AWS S3 之上。你可以通过使用可扩展的大数据技术（如 Apache Spark）来实现此目的。

#### 增量式构建 CQRS 视图

视图创建的另一个问题是处理所有事件所需的时间和资源随着时间的推移而不断增长。最终，视图创建将变得缓慢且昂贵。解决方案是使用两步增量算法。第一步基于其先前的快照和自创建快照以来发生的事件，定期计算每个聚合实例的快照。第二步使用快照和任何后续事件创建视图。

## 7.4 实现基于 AWS DynamoDB 的 CQRS 视图

AWS DynamoDB 是一个可扩展的 NoSQL 数据库，可作为 Amazon 云上的服务使用。DynamoDB 数据模型由包含项（item）的表组成，这些项与 JSON 对象一样，是分层的名称与值对的集合。AWS DynamoDB 是一个完全托管的数据库，你可以动态地调整数据表的吞吐量规模。

# 第8章 外部 API 模式
