# 《微服务架构设计模式》读书笔记

## 书籍简介

## 读后感想

## 书中概念

**软件架构**的定义：

卡耐基梅隆大学软件工程研究所的 Len Bass 及其同事，他们在使软件架构成为一门学科方面发挥了关键作用。他们定义的软件架构如下：

> 计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。
>
> —— Bass 等著《Documenting Software Architectures: Views and Beyond》



## 章节简介

### 第1章 逃离单体地狱

单体架构的好处：

- **应用的开发很简单**：IDE和其他开发工具只需要构建这一个单独的应用程序
- **易于对应用程序进行大规模的更改**：可以更改代码和数据库模式，然后构建和部署。
- **测试相对简单直观**：开发者只需要写几个端到端的测试，启动应用程序，调用REST API，然后使用Selenium这样的工具测试用户界面。
- **部署简单明了**：开发者唯一需要做的，就是把WAR文件复制到安装了Tomcat的服务器上。
- **横向扩展不费吹灰之力**：FTGO可以运行多个实例，由一个负载均衡器进行调度。



什么是单体地狱：

- **过度的复杂性会吓退开发者**
- **开发速度缓慢**
- **从代码提交到实际部署的周期很长，而且容易出问题**
- **难以扩展**。有些情况下，应用的不同模式对资源的需求是相互冲突的。因为这些模块都是在一个应用程序内，因此在选用服务器时必须满足所有模块的需要。
- **交付可靠的单体应用是一项挑战**
- **需要长期依赖某个可能已经过时的技术栈**



扩展立方体：

- **X轴扩展：在多个实例之间请求的负载均衡**
  又称为水平复制，通过克隆实例的方式扩展
- **Y轴扩展：根据功能把应用拆分为服务**
  又称为功能性分解，通过分解不同功能的方式来实现扩展。Y轴扩展把一个单体应用分成了一组服务
- **Z轴扩展：根据请求的属性路由请求**
  又称为数据分区，通过类似客户ID的方式，把相似的数据分区进行扩展



**微服务架构作为模块化的一种形式**：

- 单体应用中，模块通常由一组编程语言所提供的结构（例如 Java 的包），或者 Java JAR文件这样的构建制品（artifact）来定义。
- 微服务架构使用服务作为模块化的单元。服务的 API 为它自身构筑了一个不可逾越的边界，你无法越过 API 去访问服务内部的类，这与采用 Java 包的单体应用完全不同。



**每个服务都拥有自己的数据库**：

微服务架构的一个关键特性是每一个服务之间都是松耦合的，它们仅通过API进行通信。实现这种松耦合的方式之一，是每个服务都拥有自己的私有数据库。



**微服务架构与SOA的异同**：

|                | SOA                                                          | 微服务                                                       |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 服务间通信     | 智能管道，例如 Enterprise Service Bus（ESB），往往采用重量级协议，例如 SOAP 或其他 WS* 标准 | 使用哑管道，例如消息代理，或者服务之间点对点通信，使用例如 REST 或 gRPC 类的轻量级协议 |
| 数据管理       | 全局数据模型并共享数据库                                     | 每个服务都有自己的数据模型和数据库                           |
| 典型服务的规模 | 较大的单体应用                                               | 较小的服务                                                   |



微服务架构的好处：

- **使大型的复杂应用程序可以持续交付和持续部署**。微服务架构拥有持续交付和持续部署所需要的可测试性和可部署性，且它使开发团队能够自主且松散耦合。
- **每个服务都相对较小并容易维护**。较小规模的代码不会把 IDE 等开发工具拖慢，这样可以提升开发者的工作效率。
- **服务可以独立部署**。
- **服务可以独立扩展**。每个服务都可以部署在适合它们需求的硬件之上。
- **微服务架构可以实现团队的自治**。
- **更容易实验和采纳新的技术**。微服务架构可以消除对某项技术栈的长期依赖。更进一步，因为服务都相对比较小，使用更好的编程语言和技术来重写一项服务变得有可能。
- **更好的容错性**。微服务架构也可以实现更好的故障隔离。

微服务架构的弊端：

- **服务的拆分和定义是一项挑战**。
  如果对系统的服务拆分出现了偏差，你很有可能构建出一个**分布式的单体应用**：一个包含了一大堆互相之间紧耦合的服务，却又必须部署在一起的所谓分布式系统。这将会把单体架构和微服务架构两者的弊端急于一身。
- **分布式系统带来的各种复杂性，使开发、测试和部署变得更困难**。
  开发人员必须处理创建分布式系统的额外复杂性。服务必须使用进程间通信机制。必须设计服务来处理局部故障，并处理远程服务不可用或出现高延迟的各种情况。
  实现跨多个服务的用例需要使用不熟悉的技术。
  IDE等开发工具都是为单体应用设计的，它们并不具备开发分布式应用所需要的特定功能支持。
  微服务架构还引入了显著的运维复杂性。
- **当部署跨越多个服务的功能时需要谨慎地协调更多开发团队**。
  必须制定一个发布计划，把服务按照依赖关系进行排序。
- **开发者需要思考到底应该在应用的什么阶段使用微服务架构**。
  快速发展业务模型和维护一个优雅的应用架构之间的取舍。



**微服务架构并不是“银弹”**

早在1986年，《人月神话》的作者 Fred Brooks 就曾说：软件工程的世界里没有银弹。换一种说法，并不存在一种或几种技术，可以把你的生产效率提升10倍。

> Gartner的**光环曲线**
>
> 光环曲线采用五个阶段来描述新兴技术的发展：
>
> - *萌芽期，又称“技术诱发期”，这一时期是技术探索或公开演示的时期*（原文无此段）
> - 其中的过热期，又被称为**期望释放的顶峰**，代表了人们对新技术的迷恋和崇拜
> - *攀升期，又称“顿悟的斜坡”，这一时期尽管公众关注度下降，讨论新技术不再是时髦的，但是更多的组织对新技术的应用，以及新技术的风险和益处的了解，使得新技术逐步走向商业化的道路*（原文无此段）
> - 紧接着而来的是谷底期，又被称为**失望的山谷**，反映了人们对新技术的失望
> - 光环曲线的最后阶段才是成熟期，又被称为**生产力的高地**，是指人们理解了新技术的优缺点之后开始理性地应用它



**微服务架构的模式语言概述**：

采用微服务架构后引入的新问题的模式被分为三组：

- **基础设施相关模式组**：这些模式解决通常是开发环节跟基础设施有关的问题。
- **应用基础设施相关模式组**：这些模式解决应用层面的基础设施相关问题。
- **应用相关模式组**：这些模式解决开发人员面对的具体技术和架构问题。

![微服务架构模式语言概述](.\图片\微服务架构设计模式_微服务架构模式语言概述.png)

其中有主要的几组模式：

- **服务拆分的相关模式**：根据业务能力分解模式、根据子域分解模式（第2章）
- **通信的相关模式**：通信风格、服务发现、可靠性、事务性消息（第3章）、外部API（第8章）
- **实现事务管理的数据一致性相关模式**：（第4~6章）
- **在微服务架构中查询数据的相关模式**：API组合模式、命令查询职责隔离CQRS（第7章）
- **服务部署的相关模式**：（第12章）
- **可观测性的相关模式**：健康检查API、日志聚合、分布式追踪、异常追踪、应用指标、审计日志（第11章）
- **实现服务自动化测试的相关模式**：消费端驱动的契约测试、消费端契约测试、服务组件测试（第9章和第10章）
- **解决基础设施和边界问题的相关模式**：（第11章）
- **安全相关的模式**：令牌模式（第11章）



### 第2章 服务的拆分策略

**软件架构的4+1视图模型**：

![4+1视图模型](.\图片\微服务架构设计模式_4+1视图模型.png)

4是四个不同的软件架构视图

- **逻辑视图**：开发人员创建的软件元素。元素：类和包，关系：它们之间的关系
- **实现视图**：构建编译系统的输出。元素：模块（JAR文件）和组件（WAR文件或可执行文件），关系：它们之间的依赖关系
- **进程视图**：运行时的组件。元素：进程，关系：进程间通信
- **部署视图**：进程如何映射到机器。元素：机器和进程，关系：网络

+1是指场景，它负责把视图串联在一起。每个场景负责描述一个视图中的多个架构元素如何协助，以完成一个请求。



**为什么架构如此重要**：

应用程序有两个层面的需求。第一类是**功能性**需求，这些需求决定一个应用程序做什么。

架构的重要性在于，它帮助应用程序满足了第二类需求：**非功能性**需求。我们把这类需求也称之为**质量属性**需求。比如运行时的可扩展性、可靠性，开发阶段的可维护性、可测试性、可扩展性和可部署性。



**分层式架构风格**

架构的典型例子是分层架构。**分层架构**将软件元素按“层”的方式组织。每个层都有明确定义的职责。分层架构还限制了层之间的依赖关系。每一层只能依赖于紧邻其下方的层（如果严格分层）或其下面的任何层。

可以将分层架构应用于前面讨论的四个视图中的任何一个。流行的三层架构是应用于逻辑视图的分层架构。它将应用程序的类组织到以下层中：

- **表现层**：包含实现用户界面或外部API的代码。
- **业务逻辑层**：包含业务逻辑
- **数据持久化层**：实现与数据库交互的逻辑

分层架构是架构风格的一个很好的例子，但它确实有一些明显的弊端：

- **单个表现层**：它无法展现应用程序可能不仅仅由单个系统调用的事实。
- **单一数据持久化层**：它无法展现应用程序可能与多个数据库进行交互的事实。
- **将业务逻辑层定义为依赖于数据持久化层**：理论上，这样的依赖性会妨碍你在没有数据库的情况下测试业务逻辑。

此外，分层架构错误地表示了精心设计的应用程序中的依赖关系。业务逻辑通常定义数据访问方法的接口或接口库。数据持久化层则定义了实现存储库接口的DAO类。换句话说，依赖关系与分层架构所描述的相反。

克服这些弊端的替代架构：六边形架构。



**六边形架构**

六边形架构是分层架构风格的替代品。六边形架构风格选择以业务逻辑为中心的方式组织逻辑视图。应用程序具有一个或多个**入站适配器**，而不是表示层，它通过调用业务逻辑来处理来自外部的请求。同样，应用程序具有一个或多个**出站适配器**，而不是数据持久化层，这些出站适配器由业务逻辑调用并调用外部应用程序。此架构的一个关键特性和优点是业务逻辑不依赖于适配器。相反，各种适配器都依赖业务逻辑。

业务逻辑具有一个或多个端口（port）。**端口**定义了一组操作，关于业务逻辑如何与外部交互。例如，在Java中，端口通常是Java接口。有两种端口：入站和出站端口。

- 入站端口是业务逻辑公开的API，它使外部应用程序可以调用它。入站端口的一个实例是服务接口，它定义服务的公共方法。
- 出站端口是业务逻辑调用外部系统的方式。出站端口的一个实例是存储库接口，它定义数据访问操作的集合。

业务逻辑周围是适配器。与端口一样，有两种类型的适配器：入站和出站。

- 入站适配器通过调用入站端口来处理来自外部世界的请求。入站适配器的一个实例是Spring MVC Controller，它实现一组REST接口（endpoint）或一组Web页面。另一个实例是订阅消息的消息代理客户端。多个入站适配器可以调用相同的入站端口。
- 出站适配器实现出站端口，并通过调用外部应用程序或服务处理来自业务逻辑的请求。出站适配器的一个实例是实现访问数据库的操作的**数据访问对象**（DAO）类。另一个实例是调用远程服务的代理类。出站适配器也可以发布事件。

![六边形架构](.\图片\微服务架构设计模式_六边形架构.png)

六边形架构风格的一个重要好处是它将业务逻辑与适配器中包含的表示层和数据访问层的逻辑分离开来。业务逻辑不依赖于表示层逻辑或数据访问层逻辑。

由于这种分离，单独测试业务逻辑要容易得多。另一个好处是它更准确地反映了现代应用程序的架构。可以通过多个适配器调用业务逻辑，每个适配器实现特定的API或用户界面。业务逻辑还可以调用多个适配器，每个适配器调用不同的外部系统。六边形架构是描述微服务架构中每个服务的架构的好方法。