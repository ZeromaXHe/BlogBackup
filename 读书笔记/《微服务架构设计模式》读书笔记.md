# 第3章 微服务架构中的进程间通信

## 3.1 微服务架构中的进程间通信概述

服务可以使用基于同步请求 / 响应的通信机制，例如 HTTP REST 或 gRPC。另外，也可以使用异步的基于消息的通信机制，比如 AMQP 或 STOMP。

消息的格式也不尽相同。服务可以使用具备可读性的格式，比如基于文本的 JSON 或 XML。也可以使用更加高效的、基于二进制的 Avro 或 Protocol Buffers 格式。

### 3.1.1 交互方式

有多种客户端与服务的交互方式。它们可以分为两个维度。

第一个维度关注的是一对一和一对多。

- **一对一**：每个客户端请求由一个服务实例来处理。
- **一对多**：每个客户端请求由多个服务实例来处理。

交互方式的第二个维度关注的是同步和异步。

- **同步模式**：客户端请求需要服务端实时响应，客户端等待响应时可能导致堵塞。
- **异步模式**：客户端请求不会阻塞进程，服务端的响应可以是非实时的。

|              | 一对一                       | 一对多                           |
| ------------ | ---------------------------- | -------------------------------- |
| **同步模式** | 请求 / 响应                  | 无                               |
| **异步模式** | 异步请求 / 响应<br/>单向通知 | 发布 / 订阅 <br/>发布 / 异步响应 |

一对一的交互方式有以下几种类型。

- **请求 / 响应**：一个客户端向服务端发起请求，等待响应；客户端期望服务端很快就会发送响应。在一个基于线程的应用中，等待过程可能造成线程阻塞。这样的方式会导致服务的紧耦合。
- **异步请求 / 响应**：客户端发送请求到服务端，服务端异步响应请求。客户端在等待响应时不会阻塞线程，因为服务端的响应不会马上就返回。
- **单向通知**：客户端的请求发送到服务端，但是并不期望服务端做出任何响应。

一对多的交互方式有以下几种类型：

- **发布 / 订阅方式**：客户端发布通知消息，被零个或多个感兴趣的服务订阅。
- **发布 / 异步响应方式**：客户端发布请求消息，然后等待从感兴趣的服务发回的响应。

### 3.1.2 在微服务架构中定义 API

API 或接口是软件开发的中心。应用是由模块构成的，每个模块都有接口，这些接口定义了模块的客户端可以调用若干操作。一个设计良好的接口会在暴露有用功能同时隐藏实现的细节。因此，这些实现的细节可以被修改，而接口保持不变，这样就不会对客户端产生影响。

无论选择哪种进程间通信机制，使用某种**接口定义语言**（IDL）精确定义服务的API都很重要。

### 3.1.3 API的演化

#### 语义化版本控制

语义化版本控制规范为 API 版本控制提供了有用的指导。它是一组规则，用于指定如何使用版本号，并且以正确的方式递增版本号。语义化版本控制最初的目的是软件包的版本控制，但你可以将其用在分布式系统中对 API 进行版本控制。

语义化版本控制规范（Semvers）要求版本号由三部分组成：MAJOR、MINOR、PATCH。必须按如下方式递增版本号：

- **MAJOR**：当你对 API 进行不兼容的更改时。
- **MINOR**：当你对 API 进行向后兼容的增强时。
- **PATCH**：当你进行向后兼容的错误修复时。

#### 进行次要并且向后兼容的改变

理想情况下，你应该努力只进行向后兼容的更改。向后兼容的更改是对API的附加更改或功能增强：

- 添加可选属性。
- 向响应添加属性。
- 添加新操作。

#### 进行主要并且不向后兼容的改变

如果你使用的是基于 HTTP 的进程间通信机制，例如 REST，则一种方法是在 URL 中嵌入主要版本号。例如，版本 1 路径以 `/v1/...` 为前缀，而版本 2 路径以 `/v2/...` 为前缀。

另一种选择是使用 HTTP 的内容协商机制，并在 MIME 类型中包含版本号。

### 3.1.4 消息的格式

消息的格式可以分为两大类：文本和二进制。我们来逐一分析。

#### 基于文本的消息格式

第一类是 JSON 和 XML 这样的基于文本的格式。这类消息格式的好处在于，它们的可读性很高，同时也是自描述的。JSON 消息是命名属性的集合。相似地，XML 消息也是命名元素和值的集合。这样的格式允许消息的接收方只挑选他们感兴趣的值，而忽略掉其他。

使用基于文本格式消息的弊端主要是消息往往过度冗长，特别是 XML。消息的每一次传递都必须反复包含除了值以外的属性名称，这样会造成额外的开销。另一个弊端是解析文本引入的额外开销，尤其是在消息较大的时候。因此，在对效率和性能敏感的场景下，你可能需要考虑基于二进制格式的消息。

#### 二进制消息格式

有几种不同的二进制格式可供选择。常用的包括 Protocol Buffers 和 Avro。这两种格式都提供了一个强类型定义的 IDL（接口描述文件），用于定义消息的格式。编译器会自动根据这些格式生成序列化和反序列化的代码。

## 3.2 基于同步远程过程调用模式的通信

远程过程调用的工作原理：客户端中的业务逻辑调用**代理接口**，这个接口由**远程过程调用代理**适配器类实现。**远程过程调用代理**向服务发出请求。该请求由**远程过程调用服务器**适配器类处理，该类通过接口调用服务的业务逻辑。然后它将回复发送回**远程过程调用代理**，该代理将结果返回给客户端的业务逻辑。

**代理接口**通常封装底层通信协议。有很多协议可供选择。在本节中，我将介绍 REST 和 gRPC。

### 3.2.1 使用REST

REST 是一种（总是）使用HTTP协议的进程间通信机制，REST 之父 Roy Fielding 曾经说过：

> REST 提供了一系列架构约束，当作为整体使用时，它强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，它强化了安全性，也能封装遗留系统。

REST 中的一个关键概念是**资源**，它通常表示单个业务对象，例如客户或产品，或业务对象的集合。REST 使用 HTTP 动词来操作资源，使用URL引用这些资源。

#### REST成熟度模型

Leonard Richardson为 REST 定义了一个成熟度模型，具体包含以下四个层次。

- **Level 0**：Level 0 层级服务的客户端只是向服务端点发起 HTTP POST 请求，进行服务调用。每个请求都指明了需要执行的操作、这个操作针对的目标（例如，业务对象）和必要的参数。
- **Level 1**：Level 1 层级的服务引入了资源的概念。要执行对资源的操作，客户端需要发出指定要执行的操作和包含任何参数的POST请求。
- **Level 2**：Level 2 层级的服务使用 HTTP 动词来执行操作，譬如 GET 表示获取、POST 表示创建、PUT 表示更新。请求查询参数和主体（如果有的话）指定操作的参数。这让服务能够借助 Web 基础设施服务，例如通过 CDN 来缓存 GET 请求。
- **Level 3**：Level 3 层级的服务基于 HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是在由 GET 请求返回的资源信息中包含链接，这些链接能够执行该资源允许的操作。HATEOAS 的优点包括无须在客户端代码中写入硬链接的 URL。此外，由于资源信息中包含可允许操作的链接，客户端无须猜测在资源的当前状态下执行何种操作。

#### 定义REST API

如前面3.1节所述，你必须使用接口定义语言（IDL）定义API。与旧的通信协议（如 CORBA 和 SOAP）不同，REST 最初没有 IDL。幸运的是，开发者社区重新发现了 RESTful API 的 IDL 价值。最流行的 REST IDL 是 Open API 规范，它是从 Swagger 开源项目发展而来的。Swagger 项目是一组用于开发和记录 REST API 的工具。它包括从接口定义到生成客户端桩（stub，存根）和服务器骨架的一整套工具。

#### 在一个请求中获取多个资源的挑战

设计 REST API 时的一个常见问题是如何使客户端能够在单个请求中检索多个相关对象。更复杂的情况需要更多往返并且遭受过多的延迟。

此问题的一个解决方案是 API 允许客户端在获取资源时检索相关资源。这种方法在许多场景中都很有效，但对于更复杂的场景来说，它通常是不够的。实现它也可能很耗时。这导致替代技术的日益普及，例如 GraphQL 和 Netflix Falcor，它们旨在支持高效的数据获取。

#### 把操作映射为 HTTP 动词的挑战

另一个常见的 REST API 设计问题是如何将要在业务对象上执行的操作映射到 HTTP 动词。REST API 应该使用 PUT 进行更新，但可能有多种方法来更新订单，包括取消订单、修改订单等。此外，更新可能不是幂等的，但这却是使用 PUT 的要求。一种解决方案是定义用于更新资源的特定方面的子资源。另一种解决方案是将动词指定为 URL 的查询参数。可惜的是，这两种解决方案都不是特别符合 RESTful 的要求。

映射操作到 HTTP 动词的这个问题导致了 REST 替代方案的日益普及，例如 gRPC，我将在3.2.2节中讨论这项技术。

#### REST 的好处和弊端

REST有如下好处：

- 它非常简单，并且大家都很熟悉。
- 可以使用浏览器扩展（比如 Postman 插件）或者 curl 之类的命令行（假设使用的是 JSON 或其他文本格式）来测试 HTTP API。
- 直接支持请求/响应方式的通信。
- HTTP 对防火墙友好。
- 不需要中间代理，简化了系统结构。

它也存在一些弊端：

- 它只支持请求/响应方式的通信。
- 可能导致可用性降低。由于客户端和服务直接通信而没有代理来缓冲消息，因此它们必须在 REST API 调用期间都保持在线。
- 客户端必须知道服务实例的位置（URL）。如3.2.4节所述，这是现代应用程序中的一个重要问题。客户端必须使用所谓的**服务发现机制**来定位服务实例。
- 在单个请求中获取多个资源具有挑战性。
- 有时很难将多个更新操作映射到 HTTP 动词。

### 3.2.2 使用gRPC

如上一节所述，使用 REST 的一个挑战是，由于 HTTP 仅提供有限数量的动词，因此设计支持多个更新操作的 REST API 并不总是很容易。避免此问题的进程间通信技术是 gRPC，这是一个用于编写跨语言客户端和服务端的框架。gRPC 是一种基于二进制消息的协议，你不得不采用 API 优先的方法来进行服务设计。你可以使用基于 Protocol Buffer 的 IDL 定义 gRPC API，这是谷歌公司用于序列化结构化数据的一套语言中立机制。

gRPC API 由一个或多个服务和请求/响应消息定义组成。**服务定义**类似于 Java 接口，是强类型方法的集合。除了支持简单的请求/响应 RPC 之外，gRPC 还支持流式 RPC。服务器可以使用消息流回复客户端。客户端也可以向服务器发送消息流。

gRPC 使用 Protocol Buffers 作为消息格式。

gRPC 有几个好处：

- 设计具有复杂更新操作的API非常简单。
- 它具有高效、紧凑的进程间通信机制，尤其是在交换大量消息时。
- 支持在远程过程调用和信息传递过程中使用双向流式消息方式。
- 它实现了客户端和用各种语言编写的服务端之间的互操作性。

gRPC 也有几个弊端：

- 与基于 REST/JSON 的 API 机制相比，JavaScript 客户端使用基于 gRPC 的 API 需要做更多的工作。
- 旧式防火墙可能不支持 HTTP/2。

gRPC 是 REST 的一个引人注目的替代品，但与 REST 一样，它是一种同步通信机制，因此它也存在局部故障的问题。

### 3.2.3 使用断路器模式处理局部故障

分布式系统中，当服务试图向另一个服务发送同步请求时，永远都面临着局部故障的风险。因为客户端和服务端是独立的进程，服务端很有可能无法在有限的时间内对客户端的请求做出响应。服务端可能因为故障或维护的原因而暂停。或者，服务端也可能因为过载而对请求的响应变得极其缓慢。

客户端等待响应而被阻塞，这可能带来的麻烦是在其他客户端甚至使用服务的第三方应用之间传导，并导致服务中断。

要通过合理地设计服务来防止在整个应用程序中故障的传导和扩散，这是至关重要的。解决这个问题分为两部分：

- 必须让远程过程调用代理有正确处理无响应服务的能力。
- 需要决定如何从失败的远程服务中恢复。

#### 开发可靠的远程过程调用代理

每当一个服务同步调用另一个服务时，它应该使用 Netflix 描述的方法来保护自己。这种方法包括以下机制的组合。

- **网络超时**：在等待针对请求的响应时，一定不要做成无限阻塞，而是要设定一个超时。使用超时可以保证不会一直在无响应的请求上浪费资源。
- **限制客户端向服务器发出请求的数量**：把客户端能够向特定服务发起的请求设置一个上限，如果请求达到了这样的上限，很有可能发起更多的请求也无济于事，这时就应该让请求立刻失败。
- **断路器模式**：监控客户端发出请求的成功和失败数量，如果失败的比例超过一定的阈值，就启动断路器，让后续的调用立刻失效。如果大量的请求都以失败而告终，这说明被调服务不可用，这样即使发起更多的调用也是无济于事。在经过一定的时间后，客户端应该继续尝试，如果调用成功，则解除断路器。

Netflix Hystrix 是一个实现这些和其他模式的开源库。Polly 库在 .NET 社区中很受欢迎。

#### 从服务失效故障中恢复

使用诸如 Hystrix 之类的库只是解决方案的一部分。你还必须根据具体情况决定如何从无响应的远程服务中恢复你的服务。一种选择是服务只是向其客户端返回错误。

在其他情况下，返回备用值（fallback value，例如默认值或缓存响应）可能会有意义。

### 3.2.4 使用服务发现

服务实例具有动态分配的网络位置。此外，由于自动扩展、故障和升级，服务实例集会动态更改。因此，你的客户端代码必须使用服务发现。

#### 什么是服务发现

实现服务发现有以下两种主要方式：

- 服务及其客户直接与服务注册表交互。
- 通过部署基础设施来处理服务发现。（我将在第 12 章中详细讨论这一点。）

#### 应用层服务发现模式

实现服务发现的一种方法是应用程序的服务及其客户端与服务注册表进行交互。服务实例使用服务注册表注册其网络位置。客户端首先通过查询服务注册表获取服务实例来调用服务，然后它向其中一个实例发送请求。

这种服务发现方法是两种模式的组合。

第一种模式是自注册模式。服务实例调用服务注册表的注册API来注册其网络位置。它还可以提供运行状态检查 URL，在第 11 章中有更详细的描述。**运行状态检查** URL 是一个 API 端点，服务注册表会定期调用该端点来验证服务实例是否正常且可用于处理请求。服务注册表还可能要求服务实例调用“心跳” API 以防止其注册过期。

> **模式：自注册**
>
> 服务实例向服务注册表注册自己。

第二种模式是客户端发现模式。当客户端想要调用服务时，它会查询服务注册表以获取服务实例的列表。为了提高性能，客户端可能会缓存服务实例。然后，客户端使用负载平衡算法（例如循环或随机）来选择服务实例。然后它向选择的服务实例发出请求。

> **模式：客户端发现**
>
> 客户端从服务注册表检索可用服务实例的列表，并在它们之间进行负载平衡。

Netflix 和 Pivotal 在应用层服务发现方面做了大量普及工作。Netflix 开发并开源了几个组件，包括：Eureka，这是一个高可用的服务注册表；Eureka Java 客户端；Ribbon，这是一个支持Eureka客户端的复杂HTTP客户端。Pivotal 开发了 Spring Cloud，这是一个基于 Spring 的框架，使得 Netflix 组件的使用非常简单。基于 Spring Cloud 的服务自动向 Eureka 注册，基于 Spring Cloud 的客户端因此可以自动使用 Eureka 进行服务发现。

应用层服务发现的一个好处是它可以处理多平台部署的问题（服务发现机制与具体的部署平台无关）。

应用层服务发现的一个弊端是：你需要为你使用的每种编程语言（可能还有框架）提高服务发现库。Spring Cloud 只能帮助 Spring 开发人员。如果你正在使用其他 Java 框架或非 JVM 语言（如 Node.js 或 GoLang），则必须找到其他一些服务发现框架。

应用层服务发现的另一个弊端是开发者负责设置和管理服务注册表，这会分散一定的精力。因此，最好使用部署基础设施提供的服务发现机制。

#### 平台层服务发现模式

在第12章中，你将了解许多现代部署平台（如 Docker 和 Kubernetes）都具有内置的服务注册表和服务发现机制。部署平台为每个服务提供 DNS 名称、虚拟 IP（VIP）地址和解析为 VIP 地址的 DNS 名称。客户端向 DNS 名称和 VIP 发出请求，部署平台自动将请求路由到其中一个可用服务实例。因此，服务注册、服务发现和请求路由完全由部署平台处理。

部署平台包括一个服务注册表，用于跟踪已部署服务的 IP 地址。

这种方法是以下两种模式的组合：

- **第三方注册模式**：由第三方负责（称为**注册服务器**，通常是部署平台的一部分）处理注册，而不是服务本身向服务注册表注册自己。
- **服务端发现模式**：客户端不再需要查询服务注册表，而是向DNS名称发出请求，对该DNS名称的请求被解析到路由器，路由器查询服务注册表并对请求进行负载均衡。

> **模式：第三方注册**
>
> 服务实例由第三方自动注册到服务注册表。
>
> **模式：服务端发现**
>
> 客户端向路由器发出请求，路由器负责服务发现。

由平台提供服务发现机制的主要好处是服务发现的所有方面都完全由部署平台处理。服务和客户端都不包含任何服务发现代码。因此，无论使用哪种语言或框架，服务发现机制都可供所有服务和客户使用。

平台提供服务发现机制的一个弊端是它仅限于支持使用该平台部署的服务。例如，如前所述，在描述应用程序级别发现时，基于 Kubernetes 的发现仅适用于在 Kubernetes 上运行的服务。尽管存在此限制，我建议尽可能使用平台提供的服务发现。

## 3.3 基于异步消息模式的通信

使用消息机制时，服务之间的通信采用异步交换信息的方式完成。基于消息机制的应用程序通常使用**消息代理**，它充当服务之间的中介。另一种选择是使用无代理架构，通过直接向服务发送消息来执行服务请求。服务客户端通过向服务发送消息来发出请求。如果希望服务实例回复，服务将通过向客户端发送单独的消息的方式来实现。由于通信是异步的，因此客户端不会堵塞和等待回复。相反，客户端都假定回复不会马上就收到。

> **模式：消息**
>
> 客户端使用异步消息调用服务。

### 3.3.1 什么是消息传递

Gregor Hohpe 和 Bobby Woolf 在《Enterprise Integration Patterns》一书中定义了一种有用的消息传递模型。在此模型中，消息通过消息通道进行交换。发送方（应用程序或服务）将消息写入通道，接收方（应用程序或服务）从通道读取消息。

#### 关于消息

消息由消息头部和消息主体组成。**标题**是名称与值对的集合，描述正在发送的数据的元数据。除了消息发送者提供的名称与值对之外，消息头部还包含其他信息，例如发件人或消息传递基础设施生成的**唯一消息 ID**，以及可选的**返回地址**，该地址指定发送回复的消息通道。消息**正文**是以文本或二进制格式发送的数据。

有以下几种不同类型的消息。

- **文档**：仅包含数据的通用信息。接收者决定如何解释它。对命令式消息的回复是文档消息的一种使用场景。
- **命令**：一条等同于 RPC 请求的消息。它指定要调用的操作及其参数。
- **事件**：表示发送方这一端发生了重要的事件。事件通常是领域事件，表示领域对象的状态更改。

在本书描述的微服务架构实践中大量使用了命令式消息和事件式消息。

#### 关于消息通道

消息通过消息通道进行交换。发送方中的业务逻辑调用**发送端**接口，该接口封装底层通信机制。**发送端**由**消息发送**适配器类实现，该消息发送适配器类通过消息通道向接受器发送消息。**消息通道**是消息传递基础设施的抽象。调用接收器中的**消息处理程序**适配器类来处理消息。它调用接收方业务逻辑实现的**接收端接口**。任意数量的发送方都可以向通道发送消息。类似地，任意数量的接收方都可以从通道接收消息。

有以下两种类型的消息通道：点对点和发布-订阅。

- **点对点通道**向正在从通道读取的一个消息者传递消息。服务使用点对点通道来实现前面描述的一对一交互方式。例如，命令式消息通常通过点对点通道发送。
- **发布-订阅**通道将一条消息发给所有订阅的接收方。服务使用发布-订阅通道来实现前面描述的一对多交互方式。例如，事件式消息通常通过发布-订阅通道发送。

### 3.3.2 使用消息机制实现交互方式

消息机制的一个有价值的特性是它足够灵活，可以支持3.1.1节描述的所有交互方式。一些交互方式通过消息机制直接实现。其他必须在消息机制之上实现。

#### 实现请求/响应和异步请求/响应

当客户端和服务使用请求 / 响应 或 异步请求 / 响应 进行交互时，客户端会发送请求，服务会发回回复。

两种交互方式之间的区别在于，对于请求 / 响应，客户端期望服务立即响应，而对于异步请求 / 响应，则没有这样的期望。消息机制本质上是异步的，因此只提供异步请求 / 响应。但客户端可能会堵塞，直到收到回复。

客户端和服务端通过交换一对消息来实现异步请求 / 响应方式的交互。客户端发送命令式消息，该消息指定要对服务执行的操作和参数，这些内容通过服务拥有的点对点消息通道传递。该服务处理请求，并将包含结果的回复消息发送到客户端拥有的点对点通道。

客户端必须告知服务发送回复消息的位置，并且必须将回复消息与请求匹配。幸运的是，解决这两个问题并不困难。客户端发送具有**回复通道**头部的命令式消息。服务器将回复消息写入回复通道，该回复消息包含与**消息标识符**具有相同值的**相关性 ID**。客户端使用**相关性 ID** 将回复消息与请求进行匹配。

#### 实现单向通知

使用异步消息实现单向通知非常简单。客户端将消息（通常是命令式消息）发送到服务所拥有的点对点通道。服务订阅该通道并处理该消息，但是服务不会发回回复。

#### 实现发布/订阅

消息机制内置了对发布 / 订阅交互方式的支持。客户端将消息发布到由多个接收方读取的发布 / 订阅通道。

#### 实现发布/异步响应

发布 / 异步响应交互方式是一种更高级别的交互方式，它通过把发布 / 订阅和请求 / 响应这两种方式的元素组合在一起实现。客户端发布一条消息，在消息的头部中指定**回复通道**，这个通道同时也是一个发布 - 订阅通道。消费者将包含**相关性 ID** 的回复消息写入回复通道。客户端通过使用**相关性 ID** 来收集响应，以此将回复消息与请求进行匹配。

### 3.3.3 为基于消息机制的服务API创建API规范

服务的异步 API 规范必须指定消息通道的名称、通过每个通道交换的消息类型及其格式。并没有广泛采用的标准来记录通道和消息类型，你需要自己编写这样的文档。

#### 记录异步操作

可以使用以下两种不同交互方式之一调用服务的操作：

- **请求 / 异步响应式 API**
- **单向通知式 API**

#### 记录事件发布

服务还可以使用发布 / 订阅的方式对外发布事件。

### 3.3.4 使用消息代理

基于消息传递的应用程序通常使用**消息代理**，即服务通信的基础设施服务。

#### 无代理消息

在无代理的架构中，服务可以直接交换消息。ZeroMQ 是一种流行的无代理消息技术。

无代理的架构有以下一些好处：

- 运行更轻的网络流量和更低的延迟，因为消息直接从发送方发送到接收方，而不必从发送方到消息代理，再从代理转发到接收方。
- 消除了消息代理可能成为性能瓶颈或单点故障的可能性。
- 具有较低的操作复杂性，因为不需要设置的维护消息代理。

尽管这些好处看起来很吸引人，但无代理的消息具有以下明显的弊端：

- 服务需要了解彼此的位置，因此必须使用 3.2.4 节中描述的服务发现机制。
- 会导致可用性降低，因为在交换消息时，消息的发送方和接收方都必须同时在线。
- 在实现例如确保消息能够成功投递这些复杂功能时的挑战性更大。

#### 基于代理的消息

消息代理是所有消息的中介节点。发送方将消息写入消息代理，消息代理将消息发送给接收方。

使用消息代理的一个重要好处是发送方不需要知道接收方的网络位置。另一个好处是消息代理缓存消息，直到接收方能够处理它们。

流行的开源消息代理包括：

- Apache ActiveMQ
- RabbitMQ
- Apache Kafka

还有基于云的消息服务，例如 AWS kinesis 和 AWS SQS。

选择消息代理时，你需要考虑以下各种因素：

- **支持的编程语言**：你选择的消息代理应该支持尽可能多的编程语言。
- **支持的消息标准**：消息代理是否支持多种消息标准，比如AMQP和STOMP，还是它仅支持专用的消息标准？
- **消息排序**：消息代理是否能够保留消息的排序？
- **投递保证**：消息代理提供什么样的消息投递保证？
- **持久性**：消息是否持久化保存到磁盘并且能够在代理崩溃时恢复？
- **耐久性**：如果接收方重新连接到消息代理，它是否会收到断开连接时发送的消息？
- **可扩展性**：消息代理的可扩展性如何？
- **延迟**：端到端是否有较大延迟？
- **竞争性（并发）接收方**：消息代理是否支持竞争性接收方？

#### 使用消息代理实现消息通道

每个消息代理都用自己与众不同的概念来实现消息通道。如表3-2所示，ActiveMQ等JMS消息代理具有队列和主题。基于AMQP的消息代理（如RabbitMQ）具有交换和队列。Apache Kafka有主题，AWS Kinesis有流，AWS SQS有队列。更重要的是，一些消息代理提供了比本章中描述的信息和通道更灵活的消息机制。

| 消息代理                   | 点对点通道 | 发布-订阅通道            |
| -------------------------- | ---------- | ------------------------ |
| JMS                        | 队列       | 主题                     |
| Apache Kafka               | 主题       | 主题                     |
| 基于AMQP的代理，如RabbitMQ | 交换+队列  | 组播式交换和每客户端队列 |
| AWS Kinesis                | 流         | 流                       |
| AWS SQS                    | 队列       | /                        |

这里描述的几乎所有消息代理都支持点对点和发布-订阅通道。唯一的例外是AWS SQS，它仅支持点对点通道。

#### 基于代理的消息的好处和弊端

使用消息有以下很多好处。

- **松耦合**：客户端发起请求时只要发送给特定的通道即可，客户端完全不需要感知服务实例的情况，客户端不需要使用服务发现机制去获得服务实例的网络位置。
- **消息缓存**：消息代理可以在消息被处理之前一直缓存消息。像HTTP这样的同步请求/响应协议，在交换数据时，发送方和接收方必须同时在线。然而，在使用消息机制的情况下，消息会在队列中缓存，直到它们被接收方处理。
- **灵活的通信**：消息机制支持前面提到的所有交互方式。
- **明确的进程间通信**：基于RPC的机制总是企图让远程服务调用跟本地调用看上去没有什么区别（在客户端和服务端同时使用远程调用代理）。然而，因为物理定律（如服务器不可预计的硬件失败）和可能的局部故障，远程和本地调用还是大相径庭的。消息机制让这些差异变得很明确，这样程序员不会陷入一种“太平盛世”的错觉。

然而，消息机制也有如下一些弊端。

- **潜在的性能瓶颈**：消息代理可能存在性能瓶颈。幸运的是，许多现代消息代理都支持高度的横向扩展。
- **潜在的单点故障**：消息代理的高可用性至关重要，否则系统整体的可靠性将受到影响。幸运的是，大多数现代消息代理都是高可用的。
- **额外的操作复杂性**：消息系统是一个必须独立安装、配置和运维的系统组件。

### 3.3.5 处理并发和消息顺序

基于消息的架构挑战之一是如何在保留消息顺序的同时，横向扩展多个接收方的实例。而且，即使单个服务实例也可能使用线程来同时处理多个消息。同时处理消息的挑战是确保每个消息只被处理一次，并且是按照它们发送的顺序来处理的。

现代消息代理（如 Apache Kafka 和 AWS Kinesis）使用的常见解决方案是使用**分片**（分区）通道。该解决方案分为三个部分：

1. 分片通道由两个或多个分片组成，每个分片的行为类似于一个通道。
2. 发送方在消息头部指定分片键，通常是任意字符串或字节序列。消息代理使用分片键将消息分配给特定的分片。例如，它可以通过计算分片键的散列来选择分片。
3. 消息代理将接收方的多个实例组合在一起，并将它们视为相同的逻辑接收方。例如，Apache Kafka 使用术语**消费者组**。消息代理将每个分片分配给单个接收器。它在接收方启动和关闭时重写分配分片。

### 3.3.6 处理重复消息

使用消息机制时必须解决的另一个挑战是处理重复消息。理想情况下，消息代理应该只传递一次消息，但保证有且仅有一次的消息传递通常成本很高。相反，大多数消息代理承诺**至少**成功传递一次消息。

处理重复消息有以下两种不同的方法：

- 编写幂等消息处理程序。
- 跟踪消息并丢弃重复项。

#### 编写幂等消息处理器

如果应用程序处理消息的逻辑是满足幂等的，那么重复的消息就是无害的。所谓应用程序的**幂等性**，是指即使这个应用被相同输入参数多次重复调用时，也不会产生额外的效果。

#### 跟踪消息并丢弃重复项

一个简单的解决方案是消息接收方使用消息 id 跟踪它已处理的消息并丢弃任何重复项。

另一个选项是消息处理程序在应用程序表，而不是专用表中记录消息 id。

### 3.3.7 事务性消息

服务通常需要在更新数据库的事务中发布消息。数据库更新和消息发送都必须在事务中进行。否则，服务可能会更新数据库，然后在发送消息之前崩溃。如果服务不以原子方式执行这两个操作，则类似的故障可能使系统处于不一致状态。

传统的解决办法是在数据库和消息代理之间使用分布式事务。然而，在第 4 章中你会了解到，分布式事务对现今的应用程序而言并不是一个很好的选择。而且，很多新的消息代理，例如 Apache Kafka 并不支持分布式事务。

#### 使用数据库表作为消息队列

可靠地发布消息的直接方法是应用事务性发件箱模式。此模式使用数据库表作为临时消息队列。

> **模式：事务性发件箱**
>
> 通过将事件或消息保存在数据库的 OUTBOX 表中，将其作为数据库事务的一部分发布。

你可以对某些 NoSQL 数据库使用类似的方法。

挑战在于有效地找到那些拥有事件并发布事件的业务实体。



将消息从数据库移动到消息代理并对外发送有两种不同的方法。

#### 通过轮询模式发布事件

如果应用程序使用关系型数据库，则对外发布插入 OUTBOX 表的消息的一种非常简单的方法是让 `MessageRelay` 在表中轮询未发布的消息。

接下来，`MessageRelay` 把这些消息发送给消息代理，它把每个消息发送给它们的目标消息通道。最后，`MessageRelay` 把完成发送的消息从 OUTBOX 表中删除。

> **模式：轮询发布数据**
>
> 通过轮询数据库中的发件箱来发布消息。

轮询数据库是一种在小规模下运行良好的简单方法。其弊端是经常轮询数据库可能造成昂贵的开销（导致数据库性能下降）。此外，你是否可以将此方法与 NoSQL 数据库一起使用取决于 NoSQL 数据库支持的查询功能。

#### 使用事务日志拖尾模式发布事件

更加复杂的实现方式，是让 `MessageRelay` **拖尾**数据库的事务日志文件（也称为提交日志）。每次应用程序提交到数据库的更新都对应着数据库事务日志中的一个条目。事务日志挖掘器可以读取事务日志，把每条跟消息有关的记录发送给消息代理。

> **模式：事务日志拖尾**
>
> 通过拖尾事务日志发布对数据库所做的更改。

这个方案有一些实际的应用案例和实践可供参考：

- **Debezium**：一个开源项目，它可以向 Apache Kafka 消息代理发布数据库修改。
- **LinkedIn Databus**：一个开源项目，用于挖掘 Oracle 事务日志文件并将更改发布为事件。LinkedIn 使用 Databus 将各种派生数据存储与记录系统同步。
- **DynamoDB streams**：包含过去 24 小时内的 DynamoDB 表更改（创建、更新和删除）的序列，并且这个序列是按时间排序的。应用程序可以从流中读取这些更改，例如，将它们作为事件发布。
- **Eventuate Tram**：这是我自己的开源事务消息库，它使用 MySQL binlog 协议、Postgres WAL 或轮询来读取对 OUTBOX 表所做的更改并将它们发布到 Apache Kafka。

### 3.3.8 消息相关的类库和框架

服务需要使用库来发送和接收消息。一种方法是使用消息代理的客户端库，但是直接使用这样的库有几个问题：

- 客户端库将发布消息的业务逻辑耦合到消息代理 API。
- 消息代理的客户端库通常是非常底层的，需要多行代码才能发送或接收消息。
- 客户端库通常只能提供发送和接收消息的基本机制，不支持更高级别的交互方式。

更好的方法是使用更高级别的库或框架来隐藏底层的细节，并直接支持更高级别的交互方式。

## 3.4 使用异步消息提高可用性

### 3.4.1 同步消息会降低可用性

REST 是一种非常流行的进程间通信机制。REST 的问题在于它是一个同步协议：HTTP 客户端必须等待服务端返回响应。只要服务使用同步协议进行通信，就可能降低应用程序的可用性。

这个问题不仅仅跟基于 REST 的通信有关。当服务必须从另一个服务获取信息后，才能够返回它客户端的调用，这种情况都会导致可用性问题。即使服务使用异步消息请求 / 响应方式的交互进行通信，也存在此问题。

如果你想最大化一个系统的可用性，就应该设法最小化系统的同步操作量。

### 3.4.2 消除同步交互

在必须处理同步请求的情况下，仍然有一些方式可以最大限度地降低同步通信的数量。

#### 使用异步交互方式

理想情况下，所有的交互都应该使用本章之前所描述的异步交互。

客户端和服务端使用消息通道发送消息来实现异步通信。这个交互过程中不存在堵塞等待响应的情况。

这样的架构非常有弹性，因为消息代理会一直缓存消息，直到有服务端接收并处理消息。

然而，问题是服务很多情况下都采用类似 REST 这样的同步通信协议的外部API，并且要求对请求立即做出响应。在这种情况下，我们可以采用复制数据的方式来提高可用性。

#### 复制数据

在请求处理环节中减少同步请求的另外一种方法，就是进行数据复制。服务维护一个数据副本，这些数据是服务在处理请求时需要使用的。这些数据的源头会在数据变化时发出消息，服务订阅这些消息来确保数据副本的实时更新。

然而，复制数据的一个弊端在于，有时候被复制的数据量巨大，会导致效率低下。复制的另一个弊端在于，复制数据并没有从根本上解决服务如何更新其他服务所拥有的数据这个问题。

解决该问题的一种方法是让服务暂缓与其他服务交互，直到它给客户端发送了响应。

#### 先返回响应，再完成处理

另外一种在请求处理环节消除同步通信的办法如下：

1. 仅使用本地的数据来完成请求的验证。
2. 更新数据库，包括向 OUTBOX 表插入消息。
3. 向客户端返回响应。

当处理请求时，服务并不需要与其他服务直接进行同步交互。取而代之的是，服务异步向其他的服务发送消息。这种方式确保了服务之间的松耦合。

在完全处理请求之前响应服务的弊端是它使客户端更复杂。

# 第4章 使用 Saga 管理事务
