# 第1章 DDD对我而言

领域驱动设计（DDD）

## 1.3 战略设计

在展开具体实现细节之前，需要优先完成宏观层面的战略设计。它强调的是业务战略上的重点，如何按重要性分配工作，以及如何进行最佳整合。

首先，你需要学会运用名为**限界上下文（Bounded Context）**的战略设计模式来分离领域模型。紧接着，你会了解如何使用在明确的**限界上下文**中发展一套领域模型的**通用语言（Ubiquitous Language）**。

当进一步深入到战略设计中时，将会学到**子域（Subdomain）**，并了解如何通过它处理遗留系统中无边界的复杂性，以及如何改进新项目上的成果。还会了解如何通过名为**上下文映射（Context Maping）**的技术来集成多个限界上下文。**上下文映射图（Context map）**同时定义了两个进行集成的**限界上下文**之间的团队间关系及技术实现方式。

## 1.4 战术设计

在打好战略设计的基础之后，将会发现 DDD 最为突出的莫过于战术层面的设计工具。其中之一比较重要的工具被用来将若干实体和值对象以恰当的大小聚集在一起。这就是**聚合（Aggregate）**模式。

DDD 就是以最明确而又可行的方式对领域进行建模。使用**领域事件（Domain Events）**既可以让你明确地建立模型，也可把模型内部发生的事情分享给需要知道这一切的系统。这些相关的系统可能是你自己的本地**限界上下文**和其他的远程**限界上下文**。

# 第2章 运用限界上下文与通用语言进行战略设计

什么是**限界上下文（Bounded Context）**？什么又是**通用语言（Ubiquitous Language）**？简单地说，DDD 主要关注的是如何在明确的**限界上下文**中创建**通用语言**的模型。这种方法虽然没有错，但可能不是最清晰的描述。让我进一步解释一下这些概念。

首先，**限界上下文**是语义和语境上的边界。这意味着边界内的每个代表软件模型的组件都有着特定的含义并处理特定的事务。**限界上下文**中的这些组件有特定的上下文语境和语义理据。

如果刚刚开始投入到软件建模中，**限界上下文**多少是有些概念化的。你可以将它理解为**问题空间（Problem Space）**的一部分。然而，随着软件模型开始呈现出更深层次以及更清晰的含义时，**限界上下文**将会被迅速转换到**解决方案空间（Solution Space）**中，同时软件模型将通过项目的源代码来实现。请记住，模型是在**限界上下文**中实现的，你也将会为每个**限界上下文**开发出不同的软件。

>**什么是问题空间和解决方案空间？**
>
>问题空间是在给定项目的约束条件下进行高级战略分析与设计各个步骤的地方。
>
>解决方案空间就是真正实施解决方案的地方，这些解决方案在问题空间讨论中被识别为**核心域**（Core Domain）。当限界上下文被当作组织的关键战略举措进行开发时，即被称为核心域。

团队在**限界上下文**中发展了一种语言用于表达其边界内的软件模型，这一语言由在该**限界上下文**中开发软件模型的每个团队成员所使用。它之所以被称之为**通用语言（Ubiquitous Language）**，是因为团队成员间交流用的是它，软件模型实现的也是它。因此，**通用语言**必须严谨、精确，并且紧凑。当**限界上下文**被当作组织的关键战略举措进行开发时，即被称之为**核心域**。

> **限界上下文、团队和源代码仓库**
>
> 一个团队应该在一个限界上下文中工作。每个限界上下文应该拥有一个独立的源代码仓库。一个团队可能工作在多个限界上下文中，但是多个团队不应该在同一个限界上下文中共事。

如果没有使用限界上下文，因为这样或那样的错误，团队常常会将全新的软件产品变成一个所谓的**大泥球（Big Ball of Mud）**。

## 2.1 领域专家和业务驱动

业务部门或工作组织的划分可以很好地标明模型边界的位置。

当你意识到不同业务领域对同一术语可能有不同的定义时，就可以肯定这种分离是必要的。

DDD 强调将这些不同的概念类型分离到不同的**限界上下文**中，以此来拥抱这些差异，并且承认存在不同的**通用语言**和与之对应的职能。

## 2.3 战略设计是必要的根基

DDD 中有哪些工具可以帮助我们避免这些陷阱？你至少需要两种基本的战略设计工具，**限界上下文**和**通用语言**。采用**限界上下文**会迫使我们回答“什么是核心？”的问题。它应紧紧地抓住战略举措中所有的核心概念，并排除其他概念，剩下的都应该是团队**通用语言**的一部分。

然而，我们该如何确定核心？为此，我们必须将两个重要的群体——**领域专家（Domain Expert）**和软件开发人员，整合成一个有凝聚力的协作团队。

**领域专家**自然会更加关注业务问题。他们的想法会集中在组织如何运作的愿景上。

> **产品负责人还是领域专家？**
>
> 在某些情况下，他们可能是同一个人。产品负责人常常更加关注管理和产品待办项的优先级顺序，并时刻留意着项目的概念和技术是否保持着连续性。但这不意味着产品负责人天生就是领域内的业务核心竞争力方面的专家。我们要确保团队中有真正的领域专家，还要避免让缺乏必要专业技能的产品负责人代替领域专家。

在 DDD 项目的实施过程中，开发人员需要尽量克制这种“以技术为中心”的冲动，以防无法接受以业务为中心的核心战略举措。相反开发人员应当抛弃任何多余的技术洁癖，并拥抱团队在特定**限界上下文**中逐步发展的**通用语言**。

> **专注业务复杂性而非技术复杂性**
>
> 之所以会采用 DDD，是因为业务模型的高度复杂。我们从未想过让领域模型比其更复杂。不过，也正是因为业务模型比项目的技术特性更加复杂，我们才会使用 DDD。这也是开发人员必须与领域专家一起深入钻研业务模型的原因。

开发人员和**领域专家**都应该拒绝任何以文档为主要交流手段的倾向。最佳的**通用语言**是通过协作反馈循环而发展出来的，从中可以促成团队形成共同的心智模型。对当前知识领域的开放式讨论、探索和质疑都会深化团队对于核心域的认知。

## 2.5 发展通用语言

我们不要将**核心域**局限在名词上。相反，应当使用一组具体场景来表达**核心域**，这些场景描述了领域模型应该做的事情。本书所定义的场景，其真正含义是领域模型该如何工作，各种组件该做什么。

### 2.5.1 应用场景

你可能想知道如何把书面场景转换成某种可以用来验证领域模型是否符合团队需求说明的产出物。可以采用一种被称为**实例化需求[Specification]**的技术，它也被称为**行为驱动开发[BDD]**。你期望通过这些方法达到这些效果：协作发展并完善**通用语言**、团队共识建模，以及确定模型是否符合需求说明的需求。我们通过创建验收测试来达到这些效果。

“假如/当/那么（Given/When/Then）”的场景编写方式比之前的例子要好。

你并非一定要使用这种形式的可执行需求说明来验证场景与领域模型是否一致。你也可以使用单元测试框架来达成同样的目标，通过它创建验收测试（不是单元测试）来验证领域模型。

### 2.5.2 如何持续

事实上，最佳的学习方式，即知识获取，将在一段很长的时间持续发生，甚至发生在所谓的“维护期”。

最糟糕的情况可能是给**核心域**贴上“维护阶段”的标签。持续学习的过程根本不是一个阶段。早期发展的**通用语言**必定随着岁月的流逝而不断成长。

## 2.6 架构

**限界上下文**内会有什么？当使用**端口（Port）**和**适配器（Adapter）**的架构图时，你会发现**限界上下文**的组成绝不仅仅只是一个领域模型。

下面这些层次在**限界上下文**中很常见：

- **输入适配器（Input Adapter）**，例如用户界面控制器、REST 终端节点和消息监听器。
- 编排用例和管理事务的**应用服务（Application Service）**
- 我们一直关注的领域模型
- 还有**输出适配器（Output Adapter）**，如持久化管理和消息发送器。

我们可以使用端口和适配器作为一种基础架构，但这不是在 DDD 中唯一可用的架构。除了端口和适配器，你可以在 DDD 中使用任何架构，或架构模型（或是其他），并可以根据需要进行匹配或是混合使用。

- 事件驱动架构，**事件溯源**。在本书第 6 章中将会讨论事件溯源。
- 命令与查询职责分离（CQRS）。
- 响应式架构和 Actor 模型
- 具象状态传输（REST）
- 面向服务的架构（SOA）
- 《微服务设计》一书中解释了微服务本质上等同于 DDD 中的限界上下文
- 云计算和微服务以一样的方式得到支持

# 第3章 运用子域进行战略设计

DDD 项目中总会碰到很多**限界上下文（Bounded Contexts）**。这些上下文中一定有一个将成为**核心域（Core Domain）**，而其他的限界上下文之中也会存在许多不同的**子域（Sub Domain）**。正是因为采用了 DDD 的战略设计，团队方能实现最佳的建模成果：**限界上下文**与**子域**之间一一对应。换句话说，敏捷项目管理核心即一个清晰的**限界上下文**，也是一个清晰的**子域**。在某些情况下，一个**限界上下文**中有可能存在多个子域，但这并非是最理想的建模结果。

## 3.1 什么是子域

简单地说，**子域**是整个业务领域的一部分。你可以认为**子域**代表的是一个单一的、有逻辑的领域模型。大多数的业务领域都过于庞大和复杂，难以作为整体来分析，因此我们一般只关心那些必须在单个项目中涉及的**子域**。**子域**可以用来逻辑地拆分整个业务领域，这样才能理解存在于大型复杂项目中的**问题空间**。

也可以认为**子域**是一个明确的专业领域，假设它负责为核心业务提供解决方案。这意味着特定的**子域**将会有一位或多位**领域专家**领衔，他们非常了解由这些特定**子域**促成的业务的方方面面。对你的业务而言，**子域**也有或多或少的战略意义。

如果通过 DDD 来创建**子域**，它将会被实现成一个清晰的**限界上下文**。特定业务的**领域专家**将会成为共建**限界上下文**团队的一员。

## 3.2 子域类型

项目中有三种主要的子域类型：

- **核心域（Core Domain）**：它是一个唯一的、定义明确的领域模型，要对它进行战略投资，并在一个明确的**限界上下文**中投入大量资源去精心打磨**通用语言**。它是组织中最重要的项目，因为这将是你与其他竞争者的区别所在。正是因为你的组织无法在所有领域都出类拔萃，所以必须把**核心域**打造成组织的核心竞争力。做出这样的决定需要对**核心域**进行深入的学习与理解，而这需要承诺、协作与试验。这是组织最需要在软件中倾斜其投资的方向。后面的章节中会提供加速与高效管理这些项目的方法。
- **支撑子域（Supporting Subdomain）**：这类建模场景提倡的是“定制开发”，因为找不到现成的解决方案。对它的投入无论如何也达不到与**核心域**相同的程度。也许会考虑使用外包的方式实现此类**限界上下文**，以避免因错误地认为其具有战略意义而进行巨额的投资。这类软件模型仍旧非常重要，**核心域**的成功离不开它。
- **通用子域（Generic Subdomain）**：**通用子域**的解决方案可以采购现成的，也可以采用外包的方式，抑或是由内部团队实现，但我们不用为其分配与核心域同样优质的研发资源，甚至都不如**支撑子域**。请注意不要把通用子域误认为是核心域。我们并不希望对其投资过甚。当讨论一个正在实施 DDD 的项目时，最有可能讨论的是核心域。

## 3.3 应对复杂性

业务领域中的某些系统边界将非常可能是遗留系统，它们也许是由你的组织构建的，也许是通过购买软件许可的方式获得的。此时，可能无法对这些遗留系统进行任何改造，但当它们对**核心域**产生影响时，就需要我们认真对待。为此，**子域**可以作为讨论**问题空间**的工具。

不幸的是，事与愿违，有些遗留系统与强调**限界上下文**的 DDD 设计方式大相径庭，甚至可以称之为 **无边界（unbounded）**遗留系统。这样的遗留系统正是我提到的“**大泥球**”。事实上，“**大泥球**”内充满了多个错综复杂的模型，这些模型本应被分别设计并实现，但当它们纠缠在一起时，整个系统会乱成一团。

如果使用分开的**通用语言**思考，可能遗留系统就不会成为单体**大泥球**，这至少也可以帮助我们理解如何与它进行集成。使用**子域**来思考和讨论此类遗留系统有助于我们应对大型错综复杂模型的残酷现实。当使用这类工具时，我们可以明确那些对业务更有价值、对项目更重要的**子域**，而其他子域可以降低到次要位置。

当使用 DDD 时，**限界上下文**应该与**子域**一一对应（1：1）。也就是说，如果存在一个**限界上下文**，那么它的目标就应该是对应且只对应一个**子域**模型。想要始终做到这一点很难，但在可能的前提下，尽量以这种方式去建模很重要。这样可以使**限界上下文**清晰并且始终专注于核心战略举措。

如果必须在同一个**限界上下文**（**核心域**）中创建第二个模型，应该使用一个完全独立的模块将该模型从核心域中分离出来（DDD 的**模块**基本上等同于 Scala 和 Java 中的包，或者是 F# 和 C# 的命令空间）。DDD 通过清晰的语言声明了一个模型是核心，而另一个只是它的支撑。我们可以在**解决方案空间**中使用分离**子域**这种特殊方法。

# 第4章 运用上下文映射进行战略设计

在前面的章节中，已经了解到除了**核心域**（Sub Domain）之外，每个 DDD 项目还关联着多个**限界上下文**。所有不属于**敏捷项目管理上下文**（即**核心域**）的概念都会被迁移到其他某个**限界上下文**之中。

敏捷项目管理核心域必须和其他**限界上下文**进行集成。这种集成关系在 DDD 中称为**上下文映射**（Context Mapping）。

连接两个**限界上下文**之间的线条就代表了**上下文映射**。

考虑到两个不同的**限界上下文**中存在着两种**通用语言**（Ubiquitous Language），这条线段也代表着两种语言之间的转译过程。

## 4.1 映射的种类

### 4.1.1 合作关系

**合作关系**（Partnership）关系存在于两个团队之间。每个团队各自负责一个**限界上下文**。两个团队通过互相依赖的一套目标联合起来形成**合作关系**。由于相互之间的联系非常紧密，他们经常会面对同步日程安排和相互关联的工作，他们还必须使用持续集成对保持集成工作协调一致。两个团队之间的一致步调使用粗的映射线段表示。粗线段表示两个团队彼此需要高度承诺。

### 4.1.2 共享内核

**共享内核**（Shared Kernel）用两个**限界上下文**的交集表示，它描述了这样一种关系：两个（或更多）团队之间共享着一个小规模但却通用的模型。团队必须就要共享的模型元素达成一致。有可能它们当中只有一个团队会维护、构建及测试共享模型的代码。**共享内核**通常一开始很难理解，也很难维护，这是因为团队之间的沟通必须完全开放，而且他们必须就共享模型的构成不断地达成一致。但是只要所有参与者都认同**共享内核**比**各行其道**的方式更好，就有可能获得成功。

### 4.1.3 客户-供应商

**客户-供应商**（Customer-Supplier）描述的是两个**限界上下文**之间和两个独立团队之间的一种关系：**供应商**位于上游，**客户**位于下游。支配这种关系的是**供应商**，因为它必须提供**客户**需要的东西。**客户**需要与**供应商**共同制订规则来满足各种预期，但最终却是**供应商**来决定**客户**获得的是什么以及何时获得。

### 4.1.4 跟随者

**跟随者**（Conformist）关系存在于上游团队和下游团队之间，上游团队没有任何动机满足下游团队的具体需求。由于各种原因，下游团队也无法投入资源去翻译上游模型的**通用语言**来适应自己的特定需求，因此只能顺应上游的模型。

### 4.1.5 防腐层

**防腐层**（Anticorruption Layer）是最具防御性的**上下文映射**关系，下游团队在其**通用语言**（模型）和位于它上游的**通用语言**（模型）之间创建了一个翻译层。**防腐层**隔离了下游模型与上游模型，并完成两者之间的翻译。

但凡有可能，你就应该尝试在下游模型和上游集成模型之间创建一个**防腐层**，这样才可以在你这端的集成中创造出特别适合业务需求的模型概念，并将外部概念完全地隔离。

### 4.1.6 开放主机服务

**开放式主机服务**（Open Host Service）会定义一套协议或接口，让**限界上下文**可以被当作一组服务访问。该协议是“开放的”，所有需要与**限界上下文**进行集成的客户端都可以相对轻松地使用它。通过应用程序编程接口（API）提供的服务都有详细的文档，用起来也很舒服。

**开放主机服务**的语言比其他类型的系统语言更易用。

### 4.1.7 已发布语言

**已发布语言**（Published Language）是一种有着丰富文档的信息交换语言，可以被许多消费方的**限界上下文**简单地使用和翻译。需要读写信息的消费者们可以把共享语言翻译成自己的语言，反之亦然，而在此过程中它们对集成的正确性充满信心。这种**已发布语言**可以用 XML Schema、JSON Schema 或更佳的序列化格式定义，比如 Protobuf 或 Avro。通常，同时提供和使用**已发布语言**的**开放主机服务**可以为第三方提供最佳的继承体验。这种结合使得两种**通用语言**之间的转译非常方便。

### 4.1.8 各行其道

**各行其道**（Separate Way）描述了一种情况，使用各种**通用语言**来与一个或多个**限界上下文**集成这样的方式不能产生显著的回报。也许你所寻求的功能并不能由任何一种**通用语言**提供。在这种情况下，只能在**限界上下文**中创造属于自己的特殊解决方案，并放弃针对针对这种特殊情况的集成。

### 4.1.9 大泥球

如何一步一步把系统推向**大泥球**深渊：

1. 越来越多的**聚合**因为不合理的关联和依赖而交叉污染。
2. 对**大泥球**的一部分进行维护就会牵一发而动全身，解决问题就像在“打地鼠”。
3. 只剩下“部落知识”和“个人英雄主义”，唯有同时“讲”出所有语言的极个别“超人”方能扶大厦之将倾。

如果必须与一个或多个这样的**大泥球**系统集成，请尝试针对每个这样的遗留系统创建一个**防腐层**，保护自己的模型免受污染，否则会陷入难以理解的泥潭。

## 4.2 善用上下文映射

你可能想知道提供什么样的特定接口才能和指定的**限界上下文**进行集成。这取决于负责这个**限界上下文**的团队提供的是什么。它可以是基于 SOAP 的 RPC，也可以是基于资源的 RESTful 接口，抑或是使用队列或发布订阅的消息机制。最不济你会被迫使用数据库或文件系统进行集成。

基于数据库的继承方式是一定要避免的，如果不得不以这种方式进行集成，请务必通过**防腐层**来隔离要去集成和适配的模型。

我们来看看三种更可靠的集成类型。我们将按照健壮性逐步加强的方式介绍这三种集成方式。首先我们介绍的是 RPC，接下来是 RESTful HTTP，最后是消息机制。

### 4.2.1 基于 SOAP 的 RPC

远程过程调用（Remote Procedure Call，RPC）能以多种方式工作。一种流行的方式是通过简单对象访问协议（Simple Object Access Protocol，SOAP）使用 RPC。基于 SOAP 的 RPC 背后的思路是让调用另一个系统的服务如同调用一个本地过程或方法那样简单。

然而，SOAP 请求必须通过网络传播才能抵达远程系统，成功执行并再次通过网络返回结果。在一开始实施这种继承方式时就要承受网络彻底瘫痪的风险，或者至少要承受意外的网络延迟。另外，基于 SOAP 的 RPC 还意味着客户端**限界上下文**和提供服务的**限界上下文**之间存在着紧耦合。

RPC 的主要问题是，无论是使用 SOAP 或是其他方法，它都缺乏健壮性。如果网络出现问题或托管 SOAP API 的系统出现问题，那么看似简单的过程调用将完全失败，只会留下错误的结果。

当 RPC 有效时——大部分时间它都是有效的——它是一种非常实用的集成方式。当我们可以影响服务端**限界上下文**的设计时，如果它有一个设计良好的 API 使用**已发布语言**来提供**开放主机服务**，那就最好不过了。不管怎样，客户端**限界上下文**都可以设计一层**防腐层**，将模型与多余的外部影响隔离开来。

### 4.2.2 RESTful HTTP

使用 RESTful HTTP 的集成将注意力集中在**限界上下文**之间交换的资源上，还有相关的四个主要操作：POST、GET、PUT 和 DELETE。许多人发现采用 REST 方式进行集成效果很好，因为它可以帮助他们定义出非常适合分布式计算的 API。互联网的成功让这一点不可辩驳。

支持 REST 接口的服务端**限界上下文**应该提供**开放主机服务**和**已发布语言**。资源理应被定义成**已发布语言**，而且当它们与你的REST URI 结合在一起之后，将形成天然的**开放主机服务**。

造成 RESTful HTTP 失败的原因通常和许多造成 RPC 失败的原因一样——网络或服务提供商故障，还有意外延迟。在没有网络的前提下，RESTful HTTP 无法运作，但谁又能通过跟踪这期间的日志记录来发现导致失败的原因，从而达成保证其成功的可靠性、可伸缩性以及完整性的目标呢？

使用 REST 常犯的设计错误是直接把模型中的聚合暴露成资源。服务端模型一旦发生变化，资源也会随之一起改变，这样会把**跟随者**关系强加给每个客户端。

相反，应该根据客户端驱动的用例设计出“合成”的资源。所谓“合成”，是指对客户端来说，服务端提供出来的资源必须具有它们所需要的样子和组成，而不是直接给出实际的领域模型。有时候模型看起来就像客户端需要的东西。但客户端真正所需要的是驱动资源模型的设计，而不只是保持模型的皮囊。

### 4.2.3 消息机制

在使用异步消息机制进行集成时，很多工作都是通过客户端**限界上下文**订阅由它自己或另一个**限界上下文**发布的**领域事件**（Domain Events）来完成的。使用消息机制是最健壮的集成方法之一，因为可以消除那些和阻塞（同步）形式（如 RPC 和 REST）有关的暂时性耦合。如果可以提前预见到消息交换会产生延迟，就可以构建出更健壮的系统，因为你从未期望结果会即时发生。

> **使用 REST 完成异步操作**
>
> 可以基于 REST 对有序增长的资源集合进行轮询达到异步消息机制的效果。客户端可以在后台进程中持续轮询一个 Atom Feed 资源服务，该资源提供了一个持续增长的领域事件集合。这是一种维持服务和客户端之间异步操作的安全方法，同时还能提供服务中持续发生的最新事件。如果服务因某些原因而无法使用，则客户端将简单地在固定时间间隔之后重试，或以退避算法进行重试，直到资源再次可用。



> **避免集成火车事故**
>
> 如果客户端限界上下文（C1）和服务端限界上下文（S1）集成，C1 在处理其他客户端发给它的请求时，通常不应该将发给 S1 的同步阻塞请求作为这种处理的直接结果。也就是说，当其他某个客户端（C0）向 C1 发起阻塞请求时，不允许 C1 向 S1 发起另一个阻塞请求。因为这样的做法很可能导致 C0、C1 和 S1 之间发生“集成火车事故”。你可以使用异步消息机制来避免这种事故。

通常情况下，领域事件由**限界上下文**中的**聚合**（Aggregate）发布，许多对它感兴趣的订阅方**限界上下文**都可以消费。当订阅方**限界上下文**收到**领域事件**时，将依据其类型和值进行一些操作。一般它会导致在消费方**限界上下文**中新聚合的创建或者现有**聚合**的修改。

> **领域事件的消费者是跟随者吗？**
>
> 你可能想知道领域事件如何被另一个限界上下文消费，而不会强迫这个消费方限界上下文变成跟随者。正如《实现领域驱动设计》中所建议的那样，消费者不应该使用事件发布者定义的事件类型（比如，类）。相反，他们只应该依赖事件的格式，即它们的已发布语言。这通常意味着，如果事件以 JSON 格式或者更高效的对象格式发布，那么消费者应通过解析它们获取其数据属性来消费该事件。

当然，上述内容假定订阅方**限界上下文**总是可以从被动接受的发布方**限界上下文**事件上获益。然而，有时候客户端**限界上下文**需要主动发送命令消息给服务器**限界上下文**来强制执行一些操作。这种情况下，客户端**限界上下文**依然会收到作为结果被发不出来的**领域事件**。

在使用消息进行集成的所有用例中，整体解决方案的质量很大程度上将取决于所选消息机制的质量。消息机制应支持**至少一次投递**来保证所有消息最终都会被收到。这也意味着订阅方**限界上下文**必须实现成**幂等接收者**。

**至少一次投递**是一种消息机制的模式，这种模式下消息机制将周期性地重发指定消息。在消息丢失、接收者响应不及时，或者宕机以及接收者应答回执发送失败的情况下会发生重发。由于消息机制的这种设计，即使发送者只发送了一次，消息也可能被多次投递。但是，如果接收者的设计可以处理这种情况，那就不是问题。

只要消息可以多次投递，接收方的设计就应该正确处理这种情况。**幂等接收者**描述了请求的接收者执行操作的一种方式，即使多次执行这些操作也能产生相同的结果。因此，即使多次收到相同的消息，接收者也可以妥善处理。这可能意味着接收方要么使用消息去重功能来忽略重复的消息，要么妥善地重新应用该操作，使其结果与之前处理收到的消息所产生的结果完全一致。

因为消息机制总是采用异步的**请求响应**通信方式，所以有一些延迟是正常的，也是可以预见的。服务请求应该（几乎）不会阻塞，直到服务完成。因此，设计时把消息机制放在心上意味着你至少需要时刻准备着处理一些延迟，这将使你的整体解决方案从一开始就更加健壮。

## 4.3 上下文映射示例

> **在增强事件与反向查询之间的权衡**
>
> 有时，填充足够多的数据增强事件来满足所有消费者的需求是有好处的。而有些时候，保持轻量的领域事件并让消费者在需要更多数据时进行查询会更有利。第一种选择，即增强事件，将给予从属消费者更多自治权。如果自治是你的驱动要素，请选择增强事件数据的方式。
>
> 另一方面，很难预料到所有消费者需要在领域事件中获取的每一条数据，而且如果全部提供，可能会丰富过了头。例如，在领域事件中填充数据可能是一个糟糕的安全性决策。如果是这种情况，设计轻量的领域事件和一个可以让消费者请求的安全且丰富的查询模型可能才是正确的选择。
>
> 而有些时候，需要视情况平衡地混合使用两种方法。

# 第5章 运用聚合进行战术设计

## 5.1 为什么使用它

> **什么是实体？**
>
> 一个实体模型就是一个独立的事物。每个实体都拥有一个唯一的标识符，可以将它的个体性和所有其他类型相同或者不同的实体区分开。许多时候，也许应该说绝大多数时候，实体是可变的。也就是说，它的状态会随着时间发生变化。不过，一个实体不一定必须是可变的，它也可能是不可变的。将实体与其他建模工具区分开的主要因素是它的唯一性——即它的个体性。

**聚合**是什么？它们都是由一个或多个**实体**组成，其中一个实体被称为**聚合根**（Aggregate Root）。聚合的组成还可能包括**值对象**。

> **什么是值对象？**
>
> 一个值对象，或者更简单地说，值（Value），是对一个不变的概念整体所建立的模型。在这个模型中，值就真的只有一个值。和实体不一样，它没有唯一标识符，而是由值类型封装的属性对比来决定相等性。此外，一个值对象不是事物，而是常常被用来描述、量化或者测量一个实体。

每个聚合的**根实体**（Root Entity）控制着所有聚集在其中的其他元素。**根实体**的名称就是聚合概念上的名称。你应该选择一个名称来恰当地描述聚合模型概念上的完整性。

每个聚合都会形成保证事物一致性的边界。这意味着在一个单独的聚合中，在控制被提交给数据库的事务时，它的所有组成部分必须根据业务规则保持一致。这并非意味着你不应该把那些事务完成之后不一致的元素组合到聚合中。

> **事务的更多含义**
>
> 某种程度上，在应用程序中使用事务是实现的细节。不管怎样，我所说的“事务”就是如何隔离对聚合的修改，以及如何保证业务不变性（即软件必须始终遵守的规则）在每一次业务操作中都保持一致。无论是通过原子级的数据库事务还是其他方法来控制需求，聚合的状态或者它通过事件溯源方法表现出的形式，必须始终安全和正确地进行转移和维护。

事务边界由商业动机决定，因为任何时候都是业务来决定对象集的有效状态应该是什么。换句话说，如果**聚合**没有保存在一个完整有效的状态中，那么根据业务规则所执行的业务操作会被认为是错误的。

## 5.2 聚合的经验法则

- 在聚合边界内保护业务规则不变性
- 聚合要设计得小巧
- 只能通过标识符引用其他聚合
- 使用最终一致性更新其他聚合

### 5.2.1 规则一：在聚合边界内保护业务规则不变性

规则一的意思是**聚合**的组成部分应该由业务最终决定，而且要以那些在一次事务提交中必须保持一致的内容为基础。

### 5.2.2 规则二：聚合要设计得小巧

这条规则强调，每个**聚合**的内存占用空间和事务包含范围应该相对较小。

遵守这条规则还可以带来另一个好处：每个**聚合**可以更容易地实现，因为每个关联到它的任务都可以由一个开发者掌控。这也意味着**聚合**更容易测试。

在设计**聚合**时还需要记住的是**单一职责原则**（Single Responsibility Principle，SRP）。

### 5.2.3 规则三：只能通过标识符引用其他聚合

这能进一步帮助保持聚合设计得小巧又高效，从而降低内存需求，并提升持久化存储中加载的速度。它还有助于强化不要在同一次事务中修改其他**聚合**示例的规则。在只拥有其他**聚合**标识符的情况下，获取它们的直接对象引用没那么容易。

仅使用标识符引用还有一个好处，就是**聚合**可以使用任何类型的持久化机制轻松地存储，包括关系型数据库、文档数据库、键值型存储以及数据网格 / 结构。

### 5.2.4 规则四：利用最终一致性更新其他聚合

**领域事件**由一个聚合发布并由感兴趣的**限界上下文**订阅。消息机制通过发布 / 订阅的方式把**领域事件**传递给感兴趣的**限界上下文**。感兴趣的限界上下文可能和发布领域事件的限界上下文是同一个，也有可能是另外一个。

> **如果最终一致性让人望而生畏**
>
> 运用最终一致性并非特别地困难。尽管如此，如果你没有任何经验，可能会对使用它有些疑虑。即使这样，你依然需要根据业务定义的事务边界来将模型划分成不同的聚合。然而 ，没有什么能够阻止你在一次原子数据库事务中提交对两个甚至更多聚合的修改。你可以在事务一定能提交成功的场景中使用这种方式，而在其他场景中使用最终一致性方法。这可以让你逐步地适应最终一致性技术，而不会刚开始就把步子迈得太大，只是要理解这并非是使用聚合的主流方式，并且你最终可能会遇到事务失败。

## 5.3 建立聚合模型

当你在领域模型上展开工作并实现聚合时，有一些诱惑在等待着你。**贫血领域模型**（Anemic Domain Model）就是一个令人讨厌的巨大诱惑。如果你正在使用面向对象的领域模型，而这些模型除了公有访问器（Getter 和 Setter）之外没有包含任何真正的业务行为，那就是这种模型了。如果在建模过程中过于注重技术而忽略了业务就会造成这种结果。你需要承担领域模型中的所有的开销来设计贫血模型，但从中却获益甚少。所以不要上当！

同时也要注意别把领域模型中的业务逻辑放到上层的应用服务中。这可能在不经意中就发生了，就像生理贫血一样，也不容易检查出来。将服务中的业务逻辑委托给帮助 / 工具类也不会有什么改善。服务工具类往往会显现出身份认同危机，也永远无法保持业务逻辑的连续性。请把业务逻辑放在领域模型之中。不然就要忍受**贫血领域模型**带来的问题。

> **函数式编程呢？**
>
> 当使用函数式编程范式时，规则会发生明显的变化 ：尽管贫血领域模型在使用面向对象编程范式时不是一个好主意，但在使用函数式编程范式时却可能成为一种规范标准。这是因为函数式编程范式宣扬的是数据和行为的分离。你的数据要设计成不变的数据结构或者记录类型，而你的行为将被设计成操作特定类型不变记录的纯函数。函数将返回新的值，而不是直接修改其作为参数接收的数据。这些新的值可能就是聚合的新状态，或者是表示一次聚合状态转换的领域事件。
>
> 本章中我还是主要着眼于面向对象方法，因为这种方法仍然应用得最广泛，也被理解得更透彻。但如果你正在使 函数式编程语言并准备 DDD，注意这份指南中有些规则并不适用，或者至少要重新定义才可以遵从。

接下来将展示实现基本的聚合设计所需要的一些技术组件，接下来的例子是 C# 编写的。

第一件必须做的事情是为**聚合根实体**创建一个类。

每一个**聚合根实体**都必须拥有全局唯一的标识符。

> **值对象的使用**
>
> 这里，`TenantId` 和 `ProductId` 都被建模成不可变的值对象。

接下来要记录在查找聚合时必须用到的内在属性或者字段。

你应该承担对抗**贫血领域模型**的责任。如果暴露了公有 Setter 方法，用来设置值的逻辑可能会在模型之外实现，这样很快会导致模型贫血。

最后，会添加一些复杂的行为。

~~~c#
public class Product : Entity
{
    private String description;
    private String name;
    private ProductId productId;
    private TenantId tenantId;
    
    public String Description {get; private set;}
    public String Name {get; private set;}
    
    public void PlannedProductBacklogItem(...)
    {
        ...
    }
}
~~~

### 5.3.1 慎重选择抽象级别

有效的软件模型总是建立在一套对业务行为方式的抽象之上。所以，为每个建模中的概念选择适当的抽象级别是非常有必要的。

由技术启发的实现中常常出现不正确的抽象级别。

不要被这个诱人的、实现高度抽象的陷阱所吸引，而要根据团队精炼过的**领域专家**的心智模型，脚踏实地地对**通用语言**进行建模。通过对当下的业务需求进行建模，你将省去大量的时间、预算和代码，并且避免了不必要的麻烦。更重要的是，你将通过建立能体现有效设计的准确且实用的**限界上下文**模型来为业务提供有效的服务。

### 5.3.2 大小适中的聚合

思考下面这些可以帮助你达到 致性边界目标的设计步骤：

1. 将重点先放在聚合设计的规则二上：“聚合要设计得小巧”。每个**聚合**一开始创建时只允许包含一个**实体**，并且它将作为**聚合根**。千万不要尝试在边界内放入两个实体。这样的机会很快就会出现。用你认为和单个聚合根关联最紧密的字段 / 属性填充每个实体。这里有一个重要的技巧是定义出每个用来识别和查找聚合的字段 / 属性，以及任何其他用于构造聚合并使之处于有效初始状态的内在属性。
2. 现在将重点放在聚合设计的规则一上：“聚合边界内保护业务不变性规则” 。在上一步中 ，已经声明了至少在单个实体持久化时所有内在字段 / 属性必须是最新。但是现在需要一个一个地检查每个聚合。在检查聚合 A1 时，问问领域专家需不需要更新其他已定义的聚合，来响应聚合 A1 发生的改变。为每个聚合和它的一致性规则制作一个清单，还要记录所有这些基于响应的更新的时间范围。换句话说，“聚合 A1”作为清单的标题，如果其他的聚合类型也需要更新来响应 A1 的变化，就把它们罗列在 A1 之下。
3. 现在询问领域专家，每个基于响应的更新可以等待多长时间。答案会是两种：（a）即时发生； （b）在 n 秒 / 小时 / 天之内发生。一种可行的寻找正确的业务阈值的方法是，先抛出一个夸张到显然无法接受的时间范围（比如几周或几个月）。业务专家很可能会据此提出一个可接受的时间范围作为回应。
4. 对每一个即时发生的时间范围（3a），应该坚定地考虑把这两个实体合并到同一个聚合的边界之内 。例如，聚合 A1 和聚合 A2 实际上将合并成一个新的聚合 A[1, 2]。现在之前定义的聚合 A1 和聚合 A2 将不复存在。只剩下唯一的聚合 A[1, 2]。
5. 对于每一个在给定等待时间（3b）内更新的响应聚合，将使用聚合设计的规则四来更新它们： “利用最终一致性更新其他聚合”。

请注意，业务并不会强求每个聚合都符合 3a 标准（即时一致性）。当大部分设计活动受到数据库设计和数据建模的影响时，即时一致性可能成为一种非常强烈的趋势。这些干系人有着强烈的以事务为中心的观点。然而，业务很可能并不是在任何情况下都真的需要即时一致性。要改变这种想法，可能需要花时间证明，事务是如何因为多个用户在（现在还是）臃肿聚合的不同组成部分中并发更新而失败。此外，你可以指出这种臃肿设计会带来多少内存开销。显然，这些问题才是我们要优先避免的。

### 5.3.3 可测试的单元

还应该将聚合封装设计得合理，让它们更适合单元测试。复杂的聚合将难以测试。遵循之前的规则指南将帮助你建立可测试的聚合模型。

# 第6章 运用领域事件进行战术设计

在前面的章节中已经学到了一些**领域事件**（Domain Event）的用法。**领域事件**是一条记录，记录着在**限界上下文**（Bounded Context）中发生的对业务产生重要影响的事情。目前为止，我们已经了解到领域事件是非常重要的战略设计工具。然而，领域事件往往会在战术设计的过程中被概念化并演变成**核心域**的组成部分。

我们通过因果一致性的概念来展现运用领域事件所产生的全部威力。如果业务领域中存在因果关系的操作一一即一个操作会由另一个操作引起一一在分布式系统的每个独立节点中它们被观察到的发生顺序都是一样的，这就是业务领域提供的因果一致性。这意味着存在因果关系的操作必须按照特定的顺序发生，而且，如果前一个操作没有发生，那么后面的操作就不能发生。

这种因果的线性系统架构可以通过创建并发布顺序正确的领域事件来轻松地实现。

由于战术设计的不懈努力，领域事件在领域模型中落实，并且可以在自己的或者其他限界上下文中被发布和消费。这是一种非常有效的方式，它将已发生的重要事件告知感兴趣的监听器。接下来将学习如何建立领域事件模型以及如何在**限界上下文**中使用它们。

## 6.1 设计、实现并运用领域事件

**领域事件**类型的名称应该是对过去发生的事情的陈述，即动词的过去式。

在同一次事务中同时保存修改过的**聚合**和**领域事件**非常关键。如果你使用的是对象关系映射工具，可以把聚合保存在一张表里，并且把领域事件保存在另一张事件存储表中，然后提交事务。如果你使用的是**事件溯源**（Event Sourcing），聚合的状态可以完全由领域事件自己表达。我将在本章下一节讨论事件溯源。无论使用哪种方式，在事件存储中对领域事件进行持久化都会保留它们之间的因果顺序，这些顺序和在领域模型中发生的事件相关。

一旦领域事件被保存到了事件存储中，它就可以发布给任何对它感兴趣的订阅方。这可能发生在自己的限界上下文中也可能发生在外部的限界上下文中。这是你向世界宣告的方式，宣告在你的核心域中发生了一些值得关注的事件事情。

注意，只是按照因果顺序保存领域事件并不能保证这些事件会以同样的顺序到达其他的分布式节点。因此，识别出正确因果关系的重任就落到了消费事件的限界上下文肩上。因果关系可以由领域事件类型本身表明，或者由和领域事件关联在一起的元数据表示，比如一个序列标识符或者因果标识符。序列标识符或者因果标识符可以表示导致领域事件发生的原因事件，如果原因事件尚未出现，消费者必须等它到达后才能处理先前到达的（结果）事件。某些情况下，可以忽略潜在的领域事件，这些事件已经被后续事件的关联动作取代，这种情况下因果关系具有可消除的影响。

命令和领域事件的不同在于，某些情况下不恰当的命令可以被拒绝，比如某些资源（产品、资金等） 的供应和可用性或者其他业务层面的验证导致的情况。所以，命令可能被拒绝，而领域事件是历史事实，必须无条件地接受。尽管如此，为了响应基于时间的领域事件，应用可能需要生成一条或多条命令，来执行一些动作。

## 6.2 事件溯源

**事件溯源**（Event Sourcing）可以描述为，对所有发生在聚合实例上的领域事件进行持久化，把它们当作对聚合实例变化的记录。你存储的是发生在聚合上的所有独立事件，而不是把聚合状态作为一个整体进行持久化。

一个聚合实例上发生的所有领域事件，按照它们原本发生的顺序，组成了该实例的事件流。事件流从聚合实例上发生的第一个领域事件开始，到最近发生的领域事件结束。当指定的聚合实例上发生了新的领域事件时，这些事件被迫加到该实例事件流的末尾。在聚合上重新应用事件流，可以让它的状态从持久化存储中被重建到内存中。换句话说，使用事件溯源时，出于任何原因从内存中移除的聚合将依据它的事件流完整地进行重建。

事件存储就是一个顺序存储集合或者一张表，所有领域事件都被追加到其中。由于事件存储只允许追加记录，从而使得存储进程非常快，所以可以规划在核心域上使用事件溯源，来达到高吞吐量、低延迟和高伸缩性。

> **性能意识**
>
> 如果关注的重点之一是性能，就需要了解缓存和快照的知识。首先，性能最好的是那些缓存在内存中的聚合，每次用到它们时不需要从存储中进行重建。使用 Actor 作为聚合的 Actor 模型是一种更为简便的保持缓存聚合状态的方法。
>
> 可以使用的另外一种工具是快照，从内存中释放的聚合能够以最优方式进行重建，而不需要加载事件流中的每个领域事件，这样可以节省加载时间。这将转变成在数据库中对聚合（对象、Actor 或记录）的一些增量状态的快照进行维护。

使用事件溯源最大的优势之一就是它在独立事件这个级别保存了核心域中发生的一切。这会从各个方面对业务产生非常大的帮助，有一些现在就能想象得到，比如合规性检查和数据分析，还有一些将来才会意识到。它还有一些技术上的优势，例如，软件开发人员可以利用事件流检查使用趋势或者调试源码。

另外，当使用事件溯源时，几乎一定会同时使用 CQRS 。

# 第7章 加速和管理工具