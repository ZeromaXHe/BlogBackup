# synchronized 的实现原理

# 简答

synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 

- 对于普通同步方法，锁是当前实例对象。 
- 对于静态同步方法，锁是当前类的 Class 对象。 
- 对于同步方法块，锁是 synchonized 括号里配置的对象。 

**synchonized 在 JVM 里的实现原理**：

JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但两者的实现细节不一样，从class字节码文件可以表现出来。

- 代码块同步是使用 monitorenter  和 monitorexit 指令实现的
- 方法同步是使用方法 flags 里的 ACC_SYNCHRONIZED 标志实现的

**synchronized 锁的底层实现**：

在JVM中，对象是分成三部分存在的：对象头、实例数据、对齐填充。

实例数据和对齐填充与 synchronized 无关，对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。

对象头主要结构是由Mark Word 和 Class Metadata Address 组成

- Mark Word存储对象的hashCode、锁信息或分代年龄或GC标志等信息
- Class Metadata Address是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例

锁也分不同状态，JDK 6 之前只有两个状态：无锁、有锁（重量级锁），而在 JDK 6 之后对 synchronized 进行了优化，新增了两种状态，总共就是四个状态：无锁状态、偏向锁、轻量级锁、重量级锁，其中无锁就是一种状态了。

锁的类型和状态在对象头 Mark Word 中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的 Mark Word 数据。

每一个锁都对应一个 monitor 对象，在 HotSpot 虚拟机中它是由 ObjectMonitor 实现的（C++ 实现）。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。

# 详解

Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗而引入偏向锁和轻量级锁，对 synchronized 进行了各种优化。下面介绍一下锁的存储结构和升级过程。

先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 

- 对于普通同步方法，锁是当前实例对象。 
- 对于静态同步方法，锁是当前类的 Class 对象。 
- 对于同步方法块，锁是 synchonized 括号里配置的对象。 

从 JVM 规范中可以看到 synchonized 在 JVM 里的实现原理，JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用 monitorenter  和 monitorexit 指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。 

monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结 束处和异常处，JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

## 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。 

方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。 

同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示的，Java 虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要 Javac 编译器与Java虚拟机两者共同协作支持

## Java 对象头

在JVM中，对象是分成三部分存在的：对象头、实例数据、对齐填充。

实例数据和对齐填充与 synchronized 无关。

> 实例数据存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐；
>
> 对齐填充不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充仅仅是为了使字节对齐。

synchronized 用的锁是存在 Java 对象头里的。如果对象是数组类型，则虚拟机用 3 个字宽 （Word）存储对象头，如果对象是非数组类型，则用 2 字宽存储对象头。在 32 位虚拟机中，1 字宽等于 4 字节，即 32 bit。

| 长度        | 内容                   | 说明                             |
| ----------- | ---------------------- | -------------------------------- |
| 32 / 64 bit | Mark Word              | 存储对象的 hashCode 或锁信息等   |
| 32 / 64 bit | Class Metadata Address | 存储到对象类型数据的指针         |
| 32 / 64 bit | Array length           | 数组的长度（如果当前对象是数组） |

Java 对象头里的 Mark Word 里默认存储对象的 HashCode、分代年龄和锁标记位。32 位 JVM  

的 Mark Word 的默认存储结构如表所示。

| 锁状态   | 25 bit          | 4 bit        | 1 bit<br/>是否是偏向锁 | 2 bit<br/>锁标志位 |
| -------- | --------------- | ------------ | ---------------------- | ------------------ |
| 无锁状态 | 对象的 hashCode | 对象分代年龄 | 0                      | 01                 |

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据，如表所示。

| 锁状态   | 30 bit                       | 2 bit<br/>锁标志位 |
| -------- | ---------------------------- | ------------------ |
| 轻量级锁 | 指向栈中锁记录的指针         | 00                 |
| 重量级锁 | 指向互斥量（重量级锁）的指针 | 10                 |
| GC 标记  | 空                           | 11                 |

| 锁状态 | 23 bit  | 2 bit | 4 bit        | 1 bit<br/>是否是偏向锁 | 2 bit<br/>锁标志位 |
| ------ | ------- | ----- | ------------ | ---------------------- | ------------------ |
| 偏向锁 | 线程 ID | Epoch | 对象分代年龄 | 1                      | 01                 |

在 64 位虚拟机下，Mark Word 是 64 bit 大小的，其存储结构如表所示

| 锁状态 | 56 bit                             | 1 bit<br/>cms_free | 4 bit<br/>分代年龄 | 1 bit<br/>偏向锁 | 2 bit<br/>锁标志位 |
| ------ | ---------------------------------- | ------------------ | ------------------ | ---------------- | ------------------ |
| 无锁   | unused（25 bit）hashCode（31 bit） |                    |                    | 0                | 01                 |
| 偏向锁 | ThreadID（54 bit）Epoch（2 bit）   |                    |                    | 1                | 01                 |

## 锁的升级与对比

Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。 

### 偏向锁

HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。 

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。

它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

### 轻量级锁

（1）轻量级锁加锁

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 

（2）轻量级锁解锁 

轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

### 锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                           | 使用场景                           |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗 CPU | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗 CPU                             | 线程阻塞，响应时间缓慢                         | 追求吞吐量，同步块执行速度较长     |



# 参考文档

- 《Java 并发编程的艺术》
- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》（第 3 版）
- https://blog.csdn.net/qq_36934826/article/details/95978700