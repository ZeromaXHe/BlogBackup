# 简答

面向对象方法具有三个基本特征：**封装**（Encapsulation）、**继承**（Inheritance）和**多态**（Polymorphism）。

- 其中**封装**指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；
- **继承**是面向对象实现软件复用的重要手段，当子类继承父类时，子类作为一种特殊的父类，将直接获得父类的属性和方法；
- **多态**指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。

除此之外，**抽象**也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。

虽然抽象是面向对象的重要部分，但它不是面向对象的特征之一，因为所有的编程语言都需要抽象。

# 详解

下面先介绍一下一般面试题的普遍答法——即三大特征：封装、继承、多态——的相关知识。

然后分享一下《架构整洁之道》中关于面向对象的观点，这是和一般面试题题解的套路答法不同，可以给人新的启发。

# 1 面向对象的基本特征

面向对象方法具有三个基本特征：**封装**（Encapsulation）、**继承**（Inheritance）和**多态**（Polymorphism）。

- 其中**封装**指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；
- **继承**是面向对象实现软件复用的重要手段，当子类继承父类时，子类作为一种特殊的父类，将直接获得父类的属性和方法；
- **多态**指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。

除此之外，**抽象**也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。

> **提示**：虽然抽象是面向对象的重要部分，但它不是面向对象的特征之一，因为所有的编程语言都需要抽象。当开发者进行抽象时应该考虑哪些特征是软件系统所需要的，那么这些特征就应该使用程序记录并表现出来。因此，需要抽象哪些特征没有必然的规定，而是却决于软件系统的功能需求。

面向对象还支持如下几个功能。

- **对象**是面向对象方法中最基本的概念，它的基本特点有：标识唯一性、分类性、多态性、封装性、模块独立性好。
- **类**是具有共同属性、共同方法的一类事物。类是对象的抽象；对象则是类的实例。而类是整个软件系统最小的程序单元，类的封装性将各种信息细节隐藏起来，并通过公用方法来暴露该类对外所提供的功能，从而提高了类的内聚性，降低了对象之间的耦合性。
- 对象间的这种相互合作需要一个机制协助进行，这样的机制称为“消息”。**消息**是一个实例与另一个实例之间相互通信的机制。
- 在面向对象方法中，类之间共享属性和操作的机制称为**继承**。继承具有传递性。继承可分为单继承（一个继承只允许有一个直接父类，即类等级为树形结构）与多继承（一个类允许有多个直接父类）。

> **注意**：由于多继承可能引起继承结构的混乱，而且会大大降低程序的可理解性，所以 Java 不支持多继承。

在编程语言领域，还有一个“**基于对象**”的概念，这两个概念极易混淆。通常而言，“基于对象”也使用了对象，但是无法利用现有的对象模板产生新的对象类型，继而产生新的对象，也就是说，“基于对象”没有继承的特点；而“多态”则更需要继承，没有了继承的概念也就无从谈论“多态”。面向对象方法的三大基本特征（封装、继承、多态）缺一不可。例如，JavaScript 语言就是基于对象的，它使用一些封装好的对象，调用对象的方法，设置对象的属性；但是它们无法让开发者派生新的类，开发者只能使用现有对象的方法和属性。

> （此段观点存在争议，网上也有并不认可**基于对象**这种说法的。上面暂且把《疯狂 Java 讲义》中的原文放在这，读者可以根据自己的了解自行判断）

判断一门语言是否是面向对象的，通常可以使用继承和多态来加以判断。“面向对象”和“基于对象”都实现了“封装”的概念，但是面向对象实现了“继承和多态”，而“基于对象”没有实现这些。

面向对象编程的程序员按照分工分为“类库的创建者”和“类库的使用者”。使用类库的人并不都是具备了面向对象思想的人，通常知道如何继承和派生新对象就可以使用类库了，然而他们的思维并没有真正地转过来，使用类库只是在形式上是面向对象的，而实质上只是库函数的一种扩展。

# 2 《架构整洁之道》中对面向对象的观点

> 《架构整洁之道》中对面向对象有其独特的见解，在此也分享一下作者 Robert C. Martin 的观点，供大家参考。
>
> Martin 的观点总结一下，那就是面向对象只有多态才是最核心的特征。网上也有把**抽象**算做面向对象特性之一的观点，但这里我们姑且认为标准答案就是三大特性吧，面试题估计按“**封装、继承、多态**”答就可以了。面试还是求稳，首先肯定把三大特征说完；然后如果愿意的话也可以再补充一些其他观点，体现一下对这个话题的深度思考。

设计一个优秀的软件架构要基于对**面向对象设计**（Object-Oriented Design）的深入理解及应用。但我们首先得弄明白一个问题：究竟什么是面向对象？

- 对于这个问题，一种常见的回答是“数据与函数的组合”。这种说法虽然被广为引用，但总显得并不是那么贴切，因为它似乎暗示了 o.f() 与 f(o) 之间是有区别的，这显然不是事实。面向对象理论是在 1966 年提出的，当时 Dahl 和 Nygaard 主要是将函数调用栈迁移到了堆区域中。数据结构被用作函数的调用参数这件事远比这发送的时间更早。
- 另一种常见的回答是“面向对象编程是一种对真实世界进行建模的方式”，这种回答只能算是避重就轻。“对真实世界的建模”到底要如何进行？我们为什么要这么做，有什么好处？也许这句话意味着是“由于采用面向对象方式构建的软件与真实世界的关系更紧密，所以面向对象编程可以使得软件开发更容易”——即使这样说，也仍然逃避了关键问题——面向对象编程究竟是什么？
- 还有些人在回答这个问题的时候，往往会搬出一些神秘的词语，譬如**封装**（encapsulation）、**继承**（inheritance）、**多态**（polymorphism）。其隐含意思就是说面向对象编程是这三项的有机组合，或者任何一种支持面向对象的编程语言必须支持这三个特性。

那么，我们接下来可以逐个来分析一下这三个概念。

## 2.1 封装

由于面向对象语言为我们方便而有效地封装数据和函数提供了有力的支持，导致封装这个概念经常被引用为面向对象编程定义的一部分。通过采用封装特性，我们可以把一组相关联的数据和函数圈起来，使圈外面的代码只能看见部分函数，数据则完全不可见。譬如，在实际应用中，类（class）中的公共函数和私有成员变量就是这样。

**然而，这个特性其实并不是面向对象编程所独有的**。其实 C 语言也支持完整的封装，下面来看一个简单的C程序：

```c
// point.h
struct Point;
struct Point* makePoint(double x, double y);
double distance (struct Point *p1, struct Point *p2);
```

```c
// point.c
#include "point.h"
#include <stdlib.h>
#include <math.h>

struct Point {
    double x,y;
};

struct Point* makePoint(double x, double y){
    struct Point* p = malloc(sizeof(struct Point));
    p->x = x;
    p->y = y;
    return p;
}

double distance (struct Point* p1, struct Point* p2) {
    double dx = p1->x - p2->x;
    double dy = p1->y - p2->y;
    return sqrt(dx*dx + dy*dy);
}
```

显然，使用 point.h 的程序是没有 Point 结构体成员的访问权限的。它们只能调用 `makePoint()` 函数和 `distance()` 函数，但对它们来说，Point 这个数据结构体的内部细节，以及函数的具体实现方式都是不可见的。

这正是完美封装——虽然C语言是非面向对象的编程语言。上述C程序是很常见的。在头文件中进行数据结构以及函数定义的前置声明（forward declare），然后在程序文件中具体实现。程序文件中的具体实现细节对使用者来说是不可见的。

**而 C++ 作为一种面向对象语言，反而破坏了 C 的完美封装性**。

由于一些技术原因（C++ 编译器必须要知道每个类实例的大小），C++ 编译器要求类的成员变量必须在该类的头文件中声明。这样一来，我们的 point.h 程序随之就改成了这样：

```c++
// point.h
class Point {
public:
    Point(double x, double y);
    double distance(const Point& p) const;
    
private:
    double x;
    double y;
}
```

```c++
// point.cc
#include "point.h"
#include <math.h>

Point::Point(double x, double y)
: x(x), y(y)
{}

double Point::distance(const Point& p) const {
    double dx = x-p.x;
    double dy = y-p.y;
    return sqrt(dx*dx + dy*dy);
}
```

好了，point.h 文件的使用者现在知道了成员变量 x 和 y 的存在！虽然编译器会禁止对这两个变量的直接访问，但是使用者仍然知道了它们的存在。而且，如果 x 和 y 变量名称被改变了，point.cc 也必须重新编译才行！这样的封装性显然是不完美的。

当然，C++ 通过在编程语言层面引入 public、private、protected 这些关键词，部分维护了封装性。但所有这些都是为了解决编译器自身的技术实现问题而引入的 hack——编译器由于技术实现原因必须在头文件中看到成员变量的定义。

**而 Java 和 C# 则彻底抛弃了头文件和实现文件分离的编程方式，这其实进一步削弱了封装性。**因为在这些语言中，我们是无法区分一个类的声明和定义的。

**由于上述原因，我们很难说强封装是面向对象编程的必要条件。**而事实上，有很多面向对象编程语言（例如Smalltalk、Python、JavaScript、Lua、Ruby）对封装性并没有强制性的要求。

面向对象编程在应用上确实会要求程序员尽量避免破坏数据的封装性。但实际情况是，那些声称自己提供面向对象编程支持的编程语言，相对于 C 这种完美封装的语言而言，其封装性都被削弱了，而不是加强了。

## 2.2 继承

既然面向对象编程语言并没有提供更好的封装性，那么在继承性方面又如何呢？

嗯，其实也就一般般吧。简而言之，继承的主要作用是让我们可以在某个作用域对外部定义的某一组变量与函数进行覆盖。这事实上也是 C 程序员（不仅是 C 语言，大部分同时期的编程语言都提供了将某种数据结构伪装成另一种数据结构的特性）早在面向对象编程语言发明之前就一直在做的事了。

下面，看一下刚才的 C 程序 point.h 的扩展版：

```c
// namedPoint.h
struct NamedPoint;

struct NamedPoint* makeNamedPoint(double x, double y, char* name);
void setName(struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np);
```

```c
// namedPoint.c
#include "namedPoint.h"
#include <stdlib.h>

struct NamedPoint {
    double x,y;
    char* name;
};

struct NamedPoint* makeNamePoint(double x, double y, char* name) {
    struct NamedPoint* p = malloc(sizeof(struct NamedPoint));
    p->x = x;
    p->y = y;
    p->name = name;
    return p;
}

void setName(struct NamedPoint* np, char* name) {
    np->name = name;
}

char* getName(struct NamedPoint* np) {
    return np->name;
}
```

```c
// main.c
#include "point.h"
#include "namedPoint.h"
#include <stdio.h>

int main(int ac, char** av) {
    struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, "origin");
    struct NamedPoint* upperRight = makeNamedPoint(1.0, 1.0, "upperRight");
    printf("distance=%f\n", 
           distance(
               (struct Point*) origin, 
               (struct Point*) upperRight));
}
```

请仔细观察 main 函数，这里 NamedPoint 数据结构是被当作 Point 数据结构的一个衍生体来使用的。之所以可以这样做，是因为 NamedPoint 结构体的前两个成员的顺序与 Point 结构体的完全一致。简单来说，NamedPoint 之所以可以被伪装成 Point 来使用，是因为 NamedPoint 是 Point 结构体的一个超集，同时两者共同成员的顺序也是一样的。

上面这种编程方式虽然看上去有些投机取巧，但是在面向对象理论被提出之前，这已经很常见了（这种编程方式到现在也很常见）。**其实，C++ 内部就是这样实现单继承的**。

因此，我们可以说，早在面向对象编程语言被发明之前，对继承性的支持就已经存在很久了。当然了，这种支持用了一些投机取巧的手段，并不像如今的继承这样便利易用，而且，多重继承（multiple inheritance）如果还想用这种方法来实现，就更难了。

同时应该注意的是，在 main.c 中，程序员必须强制将 NamedPoint 的参数类型转换为 Point，而在真正的面向对象编程语言中，这种类型的向上转换通常应该是隐性的。

综上所述，我们可以认为，**虽然面向对象编程在继承性方面并没有开创出新，但是的确在数据结构的伪装性上提供了相当程度的便利性**。

回顾一下到目前为止的分析，面向对象编程在封装性上得0分，在继承性上勉强可以得0.5分（满分为1）。

## 2.3 多态

在面向对象编程语言被发明之前，我们所使用的编程语言能支持多态吗？

答案是肯定的，请注意下面这段用 C 语言编写的 copy 程序：

```c
#include <stdio.h>

void copy() {
    int c;
    while((c=getchar()) != EOF)
        putchar(c);
}
```

在上述程序中，函数 `getchar()` 主要负责从 STDIN 中读取数据。但是 STDIN 究竟指代的是哪个设备呢？同样的道理，`putchar()` 主要负责将数据写入 STDOUT，而 STDOUT 又指代的是哪个设备呢？很显然，这类函数其实就具有**多态性**，因为它们的行为依赖于 STDIN 和 STDOUT 的具体类型。

这里的 STDIN 和 STDOUT 与 Java 中的接口类似，各种设备都有各自的实现。当然，这个 C 程序中是没有接口这个概念的，那么 `getchar()` 这个调用的动作是如何真正传递到设备驱动程序中，从而读取到具体内容的呢？

其实很简单，UNIX 操作系统要求每个 IO 设备都要提供 open、close、read、write 和 seek 这 5 个标准函数（UNIX 系统有很多变体，这里只是举了一个例子）。也就是说，每个 IO 设备驱动程序对这 5 种函数的实现在函数调用上必须保持一致。

首先 FILE 数据结构体中包含了相对应的 5 个函数指针，分别用于指向这些函数：

```c
struct FILE {
    void (*open)(char* name, int mode);
    void (*close)();
    int (*read)();
    void (*write)(char);
    void (*seek)(long index, int mode);
};
```

然后，譬如控制台设备的 IO 驱动程序就会提供这 5 个函数的实际定义，将 FILE 结构体的函数指针指向这些对应的实现函数：

```c
#include "file.h"

void open(char* name, int mode) {/*...*/}
void close() {/*...*/}
int read() {int c;/*...*/return c;}
void write(char c) {/*...*/}
void seek(long index, int mode) {/*...*/}

struct FILE console = {open, close, read, write, seek};
```

现在，如果 STDIN 的定义是 FILE*，并同时指向了 console 这个数据结构，那么 `getchar()` 的实现方式就是这样的：

```c
extern struct FILE* STDIN;

int getchar() {
    return STDIN->read();
}
```

换句话说，`getchar()` 只是调用了 STDIN 所指向的 FILE 数据结构体中的 read 函数指针指向的函数。

这个简单的编程技巧正是面向对象编程中多态的基础。例如在 C++ 中，类中的每个虚函数（virtual function）的地址都被记录在一个名叫 vtable 的数据结构里。我们对虚函数的每次调用都要先查下这个表，其衍生类的构造函数负责将该衍生类的虚函数地址加载到整个对象的 vtable 中。

**归根结底，多态其实不过就是函数指针的一种应用**。自从 20 世纪 40 年代末期冯·诺伊曼架构诞生那天起，程序员们就一直在使用函数指针模拟多态了。也就是说，面向对象编程在多态方面没有提出任何新概念。

当然了，**面向对象编程语言虽然在多态上并没有理论创新，但它们也确实让多态变得更安全、更便于使用了**。

用函数指针显式实现多态的问题就在于函数指针的危险性。毕竟，函数指针的调用依赖于一系列需要人为遵守的约定。程序员必须严格按照固定约定来初始化函数指针，并同样严格地按照约定来调用这些指针。只要有一个程序员没有遵守这些约定，整个程序就会产生极其难以跟踪和消除的 Bug。

面向对象编程语言为我们消除了人工遵守这些约定的必要，也就等于消除了这方面的危险性。采用面向对象编程语言让多态实现变得非常简单，让一个传统 C 程序员可以去做以前不敢想的事情。**综上所述，我们认为面向对象编程其实是对程序间接控制权的转移进行了约束**。

### 2.3.1 多态的强大性

那么多态的优势在哪里呢？为了让读者更好地理解多态的好处，我们需要再来看下刚才的 copy 程序。如果要支持新的 IO 设备，该程序需要做什么改动呢？

答案是完全不需要做任何改动！确实，我们甚至不需要重新编译该 copy 程序。为什么？因为 copy 程序的源代码并不依赖于 IO 设备驱动程序的代码。只要 IO 设备驱动程序实现了 FILE 结构体中定义的 5 个标准函数，该 copy 程序就可以正常使用它们。

简单来说，IO设备变成了copy程序的插件。

为什么 UNIX 操作系统会将 IO 设备设计成插件形式呢？因为自 20 世纪 50 年代末期以来，我们学到了一个重要经验：程序应该**与设备无关**。

插件式架构就是为了支持这种 IO 不相关性而发明的，它几乎在随后的所有操作系统中都有应用。但即使多态有如此多优点，大部分程序员还是没有将插件特性引入他们自己的程序中，因为函数指针实在是太危险了。

而面向对象编程的出现使得这种插件式架构可以在任何地方被安全地使用。

### 2.3.2 依赖反转

我们可以想象一下在安全和便利的多态支持出现之前，软件是什么样子的。在这里，源代码层面的依赖不可避免地要跟随程序的控制流。main 函数为了调用高层函数，它就必须能够看到这个函数所在的模块。在 C 中，我们会通过 #include 来实现，在 Java 中则通过 import 来实现，而在 C# 中则用的是 using 语句。总之，每个函数的调用方都必须要引用被调用方所在的模块。

显然，这样做就导致了我们在软件架构上别无选择。在这里，系统行为决定了控制流，而控制流则决定了源代码的依赖关系。

但一旦我们使用了多态，情况就不一样了

![依赖反转UML类图](.\图片\Java面向对象三大特性_依赖反转UML类图.png)

在上图中，模块 HL1 调用了 ML1 模块中的 F() 函数，这里的调用是通过源代码级别的接口来实现的。当然在程序实际运行时，接口这个概念是不存在的，HL1 会调用 ML1 中的 F() 函数（这种调用是隐性、间接进行的）。

注意模块 ML1 和接口 I 在源代码上的依赖关系（或者叫继承关系），该关系的方向和控制流正好是相反的，我们称之为**依赖反转**。这种反转对软件架构设计的影响是非常大的。

事实上，通过利用面向编程语言所提供的这种完全便利的多态实现，无论我们面对**怎样的源代码级别的依赖关系，都可以将其反转**。

通过这种方法，软件架构师可以**完全控制**采用了面向对象这种编程方式的系统中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者被调用，软件架构师都可以随意更改源代码依赖关系。

这就是面向对象编程的好处，同时也是面向对象编程这种范式的核心本质——至少对一个软件架构师来说是这样的。

这种能力有什么用呢？在下面的例子中，我们可以用它来让数据库模块和用户界面模块都依赖于业务逻辑模块，而非相反。

![业务逻辑模块依赖反转](.\图片\Java面向对象三大特性_业务逻辑模块依赖反转.png)

这意味着我们让用户界面和数据库都成为业务逻辑的插件。也就是说，业务逻辑模块的源代码不需要引入用户界面和数据库这两个模块。

这样一来，业务逻辑、用户界面以及数据库就可以被编译成三个独立的组件或者部署单元（例如 jar 文件、DLL 文件、Gem 文件等）了，这些组件或者部署单元的依赖关系与源代码的依赖关系是一致的，业务逻辑组件也不会依赖于用户界面和数据库这两个组件。

于是，业务逻辑组件就可以**独立于用户界面和数据库来进行部署**了，我们对用户界面或数据库的修改将不会对业务逻辑产生任何影响，这些组件都可以被分别独立地部署。

简单来说，当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需要更改其他组件，这就是**独立部署能力**。

如果系统中所有组件都可以独立部署，那它们就可以由不同的团队并行开发，这就是所谓的**独立开发能力**。

## 2.4 小结

面向对象编程到底是什么？业界在这个问题上存在着很多不同的说法和意见。然而对一个软件架构师来说，其含义应该是非常明确的：**面向对象就是以多态为手段来对源代码中的依赖关系进行控制的能力**，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。

> 以上第 2 节为《架构整洁之道》中作者 Robert C. Martin 对面向对象的理解

# 参考文档

- 《疯狂 Java 讲义（第 3 版）》2.1.4 面向对象的基本特征
- 《架构整洁之道》第 5 章 面向对象编程

