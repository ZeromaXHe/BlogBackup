# 简答

因为根据**二级索引**（又叫辅助索引、非聚簇索引）只能查到我们要查找记录的主键值和相应索引列的值，所以如果我们想使用二级索引查找到完整的用户记录的话，仍然需要到**聚簇索引**中再查一遍，这个过程也被称为**回表**。



因此在查询完整用户记录（即不能进行**索引覆盖**）时，对索引查询到指定数据后，还需要一次**回表**来查找整行数据的信息；所以这里存在一定的代价。虽然索引中的数据是顺序存放的，但是再进行一次回表查找的数据则是无序的，因此变为了磁盘上的离散读操作。

因为顺序读要远远快于离散读，所以如果要求访问的数据量很小，则优化器还是会选择二级索引，但是当访问的数据占整个表的数据的蛮大一部分时（一般是 20% 左右），优化器会选择通过聚簇索引来查找数据。这也就是在某些情况（如范围查找、JOIN 链接操作等）下会发现优化器并没有选择索引去查找数据，而是通过扫描聚簇索引，也就是直接进行全表的扫描来得到数据的原因。

因此对于不能进行**索引覆盖**的情况，优化器选择二级索引的情况是，通过二级索引查找的数据是少量的。这是由当前传统机械硬盘的特性所决定的，即利用顺序读来替换随机读的查找。若用户使用的磁盘是固态硬盘，随机读操作非常快，同时有足够的自信来确认使用 **二级索引 + 回表** 可以带来更好的性能，那么可以使用关键字 `FORCE INDEX` **索引提示**来强制使用某个索引。

# 详解

## 1 聚簇索引

具有以下两个特点的 B+ 树称为**聚簇索引**（又称聚集索引）：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

   （1）页内的记录是按照主键的大小顺序排成一个单向链表。

   （2）各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。

   （3）存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2. B+ 树的叶子节点存储的是完整的用户记录。

   所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

所有完整的用户记录都存放在这个**聚簇索引**的叶子节点处。这种**聚簇索引**并不需要我们在 MySQL 中显式的使用 INDEX 语句去创建，InnoDB 存储引擎会**自动的为我们创建聚簇索引**。

另外有趣的一点是，在 InnoDB 存储引擎中，**聚簇索引**就是数据的存储方式（所有的用户记录都存储在了**叶子节点**），也就是所谓的**索引即数据，数据即索引**。

## 2 二级索引和回表

**聚簇索引**只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？

我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序原则。比方说我们用 c2 列的大小作为数据页、页中记录的排序规则，再建一棵 B+ 树。

这个 B+ 树与上边介绍的聚簇索引有几处不同：

- 使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：

  （1）页内的记录是按照 c2 页的大小顺序排成一个单向链表

  （2）各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。

  （3）存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排成一个双向链表。

- B+ 树的叶子节点存储的并不是完整的用户记录，而只是 **c2 列 + 主键** 这两列的值。

- 目录项记录中不再是 **主键 + 页号** 的搭配，而变成了 **c2 列 + 页号** 的搭配。

所以如果我们现在想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树了。以查找 c2 列的值为 4 的记录为例，查找过程如下：

1. 确定**目录项记录**页
2. 通过**目录项记录**页确定用户记录真实所在的页。
3. 在真实存储用户记录的页中定位到具体的记录。
4. 但是这个 B+ 树的叶子节点中的记录只存储了 c2 和 c1（也就是**主键**）两个列，所以**我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录**。

注意上面步骤 4 的操作！我们根据这个以 c2 列大小排序的 B+ 树只能确定我们要查找记录的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到**聚簇索引**中再查一遍，这个过程也被称为**回表**。也就是根据 c2 列的查询一条完整的用户记录需要使用到 2 棵 B+ 树！

为什么我们还需要一次**回表**操作呢？直接把完整的用户记录放到**叶子节点**不就好了么？如果把完整的用户记录放到**叶子节点**是可以不用**回表**，但是太占地方了。相当于每建立一棵 B+ 树都需要把所有的用户记录都拷贝一遍，这就有点太浪费存储空间了。

因为这种按照**非主键列**建立的 B+ 树需要一次**回表**操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为**二级索引**（英文名 secondary index），或者**辅助索引**、**非聚簇索引**。由于我们使用的是 c2 列的大小作为 B+ 树的排序规则，所以我们也称这个 B+ 树为**为 c2 列建立的索引**。

### 2.1 联合索引

**联合索引**是指对表上的多个列进行索引。前面讨论的情况都是只对表的一个列进行索引。联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照 c2 列进行排序。
- 在记录的 c2 列相同的情况下，采用 c3 列进行排序

我们需要注意以下几点：

- 每条 **目录项记录** 都由 c2、c3、页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。
- B+ 树叶子节点处的用户记录由 c2、c3 和主键 c1 列组成。

千万要注意一点，**以 c2 和 c3 列的大小为排序规则建立的 B+ 树称为联合索引，本质上也是一个二级索引**。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下：

- 建立 **联合索引** 只会建立 1 棵 B+ 树。
- 为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立 2 棵 B+ 树。

## 3 优化器因回表而不使用索引

在某些情况下，当执行 EXPLAIN 命令进行 SQL 语句的分析时，会发现优化器并没有选择索引去查找数据，而是通过扫描聚簇索引，也就是直接进行全表的扫描来得到数据。这种情况多发生于范围查找、JOIN 链接操作等情况下。

这是为什么呢？原因在于用户要选取的数据是整行信息，而索引可能不能覆盖到我们要查询的信息，因此在对索引查询到指定数据后，还需要一次回表来查找整行数据的信息。虽然索引中的数据是顺序存放的，但是再进行一次回表查找的数据则是无序的，因此变为了磁盘上的离散读操作。

如果要求访问的数据量很小，则优化器还是会选择二级索引，但是当访问的数据占整个表的数据的蛮大一部分时（一般是 20% 左右），优化器会选择通过聚簇索引来查找数据。因为顺序读要远远快于离散读。

因此对于不能进行**索引覆盖**的情况，优化器选择二级索引的情况是，通过二级索引查找的数据是少量的。这是由当前传统机械硬盘的特性所决定的，即利用顺序读来替换随机读的查找。若用户使用的磁盘是固态硬盘，随机读操作非常快，同时有足够的自信来确认使用 **二级索引 + 回表** 可以带来更好的性能，那么可以使用关键字 `FORCE INDEX` **索引提示**来强制使用某个索引。

### 3.1 回表的代价

我们使用的例表 person_info 的建表语句：

~~~mysql
CREATE TABLE person_info(
     id INT NOT NULL auto_increment,
     name VARCHAR(100) NOT NULL,
     birthday DATE NOT NULL,
     phone_number CHAR(11) NOT NULL,
     country varchar(100) NOT NULL,
     PRIMARY KEY (id),
     KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
~~~

用 idx_name_birthday_phone_number 索引为例，看下边这个查询：

~~~mysql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
~~~

在使用 idx_name_birthday_phone_number 索引进行查询时大致可以分为这两个步骤：

1. 从索引 idx_name_birthday_phone_number 对应的 B+ 树中取出 name 值在 Asa ~ Barlow 之间的用户记录。
2. 由于索引 idx_name_birthday_phone_number 对应的 B+ 树用户记录中只包含 name、birthday、phone_number、id 这4个字段，而查询列表是 `*`，意味着要查询表中所有字段，也就是还要包括 country 字段。这时需要把从上一步中获取到的每一条记录的 id 字段都到聚簇索引对应的B+树中找到完整的用户记录，也就是我们通常所说的**回表**，然后把完整的用户记录返回给查询用户。

由于索引 idx_name_birthday_phone_number 对应的 B+ 树中的记录首先会按照 name 列的值进行排序，所以值在 Asa ～ Barlow 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为 **顺序 I/O** 。

根据第 1 步中获取到的记录的 id 字段的值可能并不相连，而在聚簇索引中记录是根据 id （也就是主键）的顺序排列的，所以根据这些并不连续的 id 值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为 **随机I/O** 。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引 idx_name_birthday_phone_number 的查询有这么两个特点：

- 会使用两个 B+ 树索引，一个二级索引，一个聚簇索引。
- 访问二级索引使用**顺序I/O**，访问聚簇索引使用**随机I/O**。

**需要回表的记录越多，使用二级索引的性能就越低**，甚至让某些查询宁愿使用全表扫描也不使用**二级索引**。比方说 name 值在 Asa ～ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用 idx_name_birthday_phone_number 索引的话，有 90% 多的 id 值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。

那什么时候采用全表扫描的方式，什么时候使用采用 **二级索引 + 回表** 的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 **二级索引 + 回表** 的方式。

当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这样的过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用 **二级索引 + 回表** 的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：

~~~mysql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;
~~~

添加了 `LIMIT 10` 的查询更容易让优化器采用 **二级索引 + 回表** 的方式进行查询。

对于有排序需求的查询，上边讨论的采用 **全表扫描** 还是 **二级索引 + 回表** 的方式进行查询的条件也是成立的。

### 3.2 覆盖索引

为了彻底告别 **回表** 操作带来的性能损耗，我们建议：**最好在查询列表里只包含索引列**，比如这样：

~~~mysql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
~~~

因为我们只查询 name，birthday，phone_number 这三个索引列的值，所以在通过 idx_name_birthday_phone_number 索引得到结果后就不必到**聚簇索引**中再查找记录的剩余列，也就是 country 列的值了，这样就省去了 **回表** 操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为 **索引覆盖**。

排序操作也优先使用 **覆盖索引** 的方式进行查询。

如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是**我们很不鼓励用`*`号作为查询列表，最好把我们需要查询的列依次标明**。

InnoDB 存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引（即二级索引）中就可以得到查询的记录，而不需要查询聚集索引（即聚簇索引）中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的 IO 操作。

> **注意**
>
> 覆盖索引技术最早是在 InnoDB Plugin 中完成并实现。这意味着对于 InnoDB 版本小于 1.0 的，或者 MySQL 数据库版本为 5.0 或以下的，InnoDB 存储引擎不支持覆盖索引特性。

### 3.3 索引提示

MySQL 数据库支持索引提示（INDEX HINT），显式地告诉优化器使用哪个索引。两种情况可能需要用到索引提示：

- MySQL 数据库的优化器错误地选择了某个索引，导致 SQL 语句运行得很慢。这时有经验的 DBA 或开发人员可以强制优化器使用某个索引，以此来提高 SQL 运行的速度。但这种情况在最新的 MySQL 数据库版本中非常非常的少见。优化器在绝大部分情况下工作得都非常有效和正确。
- 某 SQL 语句的可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于 SQL 语句本身。例如，优化器分析 Range 查询本身就是非常耗时的操作。这时 DBA 或开发人员分析最优的索引选择，通过索引提示来强制使优化器不进行各个执行路径的成本分析，直接选择特定的索引来完成查询。

用户确定指定某个索引来完成查询，最可靠的是使用 `FORCE INDEX`，而不是 `USE INDEX`。`USE INDEX` 关键字只是告诉优化器可以选择该索引，实际上优化器还是会再根据自己的判断进行选择，而如果使用 `FORCE INDEX` 的**索引提示**，则优化器的最终选择和用户指定的索引是一致的。

# 参考文档

- 《MySQL 是怎样运行的：从根儿上理解 MySQL》6.2.2 InnoDB中的索引方案、7.3 回表的代价
- 《MySQL 技术内幕：InnoDB 存储引擎》（第2版）5.6 B+ 树索引的使用