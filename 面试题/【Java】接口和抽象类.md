# 简答

接口和抽象类的**相同**之处：

- 接口和抽象类都不能被实例化，它们都处于继承树的顶端，用于被其他类实现和继承。
- 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

接口和抽象类的**不同**之处：

- 最主要的一点，在设计目的上，**接口作为系统与外界交互的窗口，接口体现的是一种规范；抽象类则不一样，抽象类作为多个子类的共同父类，它所体现的是一种模板式设计**。
- 接口里只能包含抽象方法、默认方法（Java 8 引入）、静态方法（Java 8 引入）和私有方法（Java 9 引入），不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。
- 接口里只能定义静态常量（接口中自动为成员变量增加 `public static final` 修饰符），不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。
- 接口里不包含构造器；抽象类里可以包含构造器，抽象类的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
- 接口里不能包含初始化块；但抽象类则完全可以包含初始化块。
- 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补 Java 单继承的不足。

# 详解

# 1 抽象类

抽象方法和抽象类必须使用 abstract 修饰符来定义，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。

抽象方法和抽象类的规则如下：

- 抽象类必须使用 abstract 修饰符来修饰，抽象方法也必须使用 abstract 修饰符来修饰，抽象方法不能有方法体。
- 抽象类不能被实例化，无法使用 new 关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。
- 抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类（接口、枚举）5 种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。
- 含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况）只能被定义成抽象类。

当使用 abstract 修饰类时，表明这个类只能被继承；当使用 abstract 修饰方法时，表明这个方法必须由子类提供实现（即重写）。而 final 修饰的类不能被继承，final 修饰的方法不能被重写。因此 final 和 abstract 永远不能同时使用。

> **注意**：abstract 不能用于修饰成员变量，不能用于修饰局部变量，即没有抽象变量、没有抽象成员变量等说法；abstract 也不能用于修饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构造器。

除此之外，当使用 static 修饰一个方法时，表明这个方法属于该类本身，即通过类就可以调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法时出现错误（调用了一个没有方法体的方法肯定会引起错误）。因此 static 和 abstract 不能同时修饰某个方法，即没有所谓的类抽象方法。

> **注意**：static 和 abstract 并不是绝对互斥的，static 和 abstract 虽然不能同时修饰某个方法，但它们可以同时修饰内部类。

> **注意**：abstract 关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此 abstract 方法不能定义为 private 访问权限，即 private 和 abstract 不能同时修饰方法。

# 2 接口

在 Java 程序设计语言中，接口不是类，而是对希望符合这个接口的类的一组**需求**。

和类定义不同，定义接口不再使用 class 关键字，而是使用 interface 关键字。接口定义的基本语法如下：

```java
[修饰符] interface 接口名 extends 父接口1, 父接口2 ... {
    零到多个常量定义...
    零到多个抽象方法定义...
    零到多个内部类、接口、枚举定义...
    零到多个默认方法或静态方法定义...
}
```

对上面语法的详细说明如下。

- 修饰符可以是 public 或省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口。
- 接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可；如果要遵守 Java 可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无须任何分隔符。接口名通常能够使用形容词。
- 一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。

由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。

前面已经说过了，接口里定义的是多个类共同的公共行为规范，因此接口里的所有成员，包括常量、方法（Java 9 引入的私有方法除外）、内部类和内部枚举都是 public 访问权限。定义接口成员时，可以省略访问控制修饰符，如果指定访问控制符，则只能使用 public 访问控制修饰符。

对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加 static 和 final 两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用 public static final 修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值。

接口里定义的方法只能是抽象方法、静态方法（Java 8 引入）、默认方法（Java 8 引入）或私有方法（Java 9 引入），因此系统将自动为普通方法增加 abstract 修饰符；定义接口里的普通方法时不管是否使用 public abstract 修饰符，接口里的普通方法总是使用 public abstract 来修饰。接口里的普通方法不能有方法实现（方法体）。

从 Java 8 起，可以在接口中定义**默认方法**，为接口方法提供一个默认实现。必须用 default 修饰符标记这样一个方法。该方法不能使用 static 修饰，无论程序是否指定，默认方法总是使用 public 修饰。

从 Java 8 起，允许在接口中增加**静态方法**，理论上来讲，没有任何理由认为这是不合法的。只是这有违于将接口作为抽象规范的初衷。静态方法必须使用 static 修饰，该方法不能使用 default 修饰，无论程序是否指定，静态方法总是使用 public 修饰。

从 Java 9 起，接口中的方法可以是 private。**私有方法**可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以只能作为接口中其他方法的辅助方法。

## 2.1 解决默认方法冲突

> 关于接口的默认方法，有一个面试题也时常问到：解决默认方法冲突。这里也简单谈一下，省得单独写一篇文章了。

如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义同样的方法，会发生什么情况？诸如 Scala 和 C++ 等语言对于解决这种二义性有一些复杂的规则。幸运的是，Java 的相应规则要简单得多。规则如下：

1. **超类优先**。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。
2. **接口冲突**。如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认方法）相同的方法，必须覆盖这个方法来解决冲突。即如果实现的多个接口中有两个同名且参数类型相同的方法，且至少有一个接口提供了一个实现，编译器就会报告错误，程序员就必须解决这个二义性。

> **注释**：当然，如果两个接口都没有为共享方法提供默认实现，那么就与 Java 8 之前的情况一样，这里不存在冲突。实现类可以有两个选择：实现这个方法，或者干脆不实现。如果是后一种情况，这个类就是抽象的。

“类优先”规则可以确保与 Java 7 的兼容性。如果为一个接口增加默认方法，这对于有这些默认方法之前能正常工作的代码不会有任何影响。

> **警告**：千万不要让一个默认方法重新定义 Object 类中的某个方法。例如，不能为 toString 或 equals 定义默认方法，尽管对于 List 之类的接口这可能很有吸引力。但由于“类优先”规则，这样的方法绝对无法超越 Object.toString 或 Objects.equals。

# 3 接口和抽象类

接口和抽象类很像，它们都具有如下特征。

- 接口和抽象类都不能被实例化，它们都处于继承树的顶端，用于被其他类实现和继承。
- 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

但接口和抽象类之间的差别非常大，这种差别主要体现在二者设计目的上。下面具体分析二者的差别。

**接口作为系统与外界交互的窗口，接口体现的是一种规范**。对于接口的实现者，接口规定了实现者必须向外提供哪些服务（以方法的形式来提供）；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法）。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。

从某种程度上来看，接口类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口被改变，对整个系统甚至其他系统的影响将是辐射式的，导致系统中大部分类都需要重写。

**抽象类则不一样，抽象类作为多个子类的共同父类，它所体现的是一种模板式设计**。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。

除此之外，接口和抽象类在用法上也存在如下差别：

- 接口里只能包含抽象方法、默认方法（java 8 引入）、静态方法（Java 8 引入）和私有方法（Java 9 引入），不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。
- 接口里只能定义静态常量（接口中自动为成员变量增加 `public static final` 修饰符），不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。
- 接口里不包含构造器；抽象类里可以包含构造器，抽象类的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
- 接口里不能包含初始化块；但抽象类则完全可以包含初始化块。
- 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补 Java 单继承的不足。

# 参考文档

- 《疯狂 Java 讲义》（第 3 版）6.5 抽象类、6.6 Java 8 改进的接口
- 《Java 核心技术 卷I 基础知识》（原书第 11 版） 5.1.9 抽象类、6.1 接口