# 简答

Kafka 就是依靠下列 4 点达到了高吞吐量、低延时的设计目标的：

- 大量使用操作系统**页缓存**，内存操作系统速度快且命中率高
- Kafka 不直接参与物理 I/O 操作，而是交由最擅长此事的操作系统来完成。
- 采用**追加写入方式**，摒弃了缓慢的磁盘随机读/写操作。
- 使用以 sendfile 为代表的**零拷贝技术**加强网络间的数据传输效率。

# 详解

# 1 吞吐量与延时

对于任何一个消息引擎而言，**吞吐量**（throughput）都是至关重要的性能指标。那么何为吞吐量呢？通常来说，**吞吐量是某种处理能力的最大值**。而对于 Kafka 而言，它的吞吐量就是每秒能够处理的消息数或者每秒能够处理的字节数。很显然，我们自然希望消息引擎的吞吐量越大越好。

消息引擎系统还有一个名为**延时**的性能指标。它衡量的是一段时间间隔，可能是发出某个操作与接收到操作响应（response）之间的时间，或者是在系统中导致某些物理变更的起始时刻与变更正式生效时刻之间的间隔。对于 Kafka 而言，延时可以表示客户端发起请求与服务器处理请求并发送给客户端之间的这一段时间。显而易见，延时间隔越短越好。

在实际使用场景中，这两个指标通常是一对矛盾体，即调优其中一个指标通常会使另一个指标变差。当然它们之间的关系也不是等比例地此消彼长的关系。例如，使用**批处理**（batching）的思想，也可以在延时确定的情况下，显著提升吞吐量。

# 2 Kafka 写入如何做到高吞吐量、低延时

首先，**Kafka 的写入操作是很快的，这主要得益于它对磁盘的使用方法的不同**。虽然 Kafka 会持久化所有数据到磁盘，但本质上每次写入操作其实都只是把数据写入到操作系统的**页缓存**（page cache）中，然后由操作系统自行决定什么时候把页缓存中的数据写回磁盘上。这样的设计有 3 个主要优势。

- 操作系统页缓存是在内存中分配的，所以消息写入的速度非常快。
- Kafka 不必直接与底层的文件系统打交道。所有烦琐的 I/O 操作都交由操作系统来处理。
- Kafka 写入操作采用追加写入（append）的方式，避免了磁盘随机写操作。

各位读者请特别留意上面的第 3 点。对于普通的物理磁盘（非固态硬盘）而言，我们总是认为磁盘的读 / 写操作是很慢的。事实上普通 SAS 磁盘随机读 / 写的吞吐量的确是很慢的，但是磁盘的顺序读 / 写操作其实是非常快的，它的速度甚至可以匹敌内存的随机 I/O 速度。

| 方式             | 访问速度   |
| ---------------- | ---------- |
| 内存顺序访问     | 358.2 MB/s |
| 内存随机访问     | 36.7 MB/s  |
| SSD 顺序访问     | 42.2 MB/s  |
| SSD 随机访问     | 1924 B/s   |
| 普通磁盘顺序访问 | 53.2 MB/s  |
| 普通磁盘随机访问 | 316 B/s    |

鉴于这一事实，Kafka 在设计时采用了追加写入消息的方式，即只能在日志文件末尾追加写入新的消息，且不允许修改已写入的消息，因此它属于典型的磁盘顺序访问型操作，所以 Kafka 消息发送的吞吐量是很高的。在实际使用中可以很轻松地做到每秒写入几万甚至几十万条消息。

# 3 Kafka 消费端如何做到高吞吐量、低延时

之前提到了 Kafka 是把消息写入操作系统的页缓存中的。那么同样地，Kafka 在读取消息时会首先尝试从 OS 的页缓存中读取，如果命中便把消息经页缓存直接发送到网络的 Socket 上。这个过程就是利用 Linux 平台的 sendfile 系统调用做到的，而这种技术就是大名鼎鼎的零拷贝（Zero Copy）技术。

传统的 Linux 操作系统中的 I/O 接口是依托于数据拷贝来实现的，但在零拷贝技术出现之前，一个 I/O 操作会将同一份数据进行多次拷贝（`内核上下文中的读缓存 → 应用上下文中的应用程序缓存 → 内核上下文的 Socket 缓存`）。数据传输过程中还涉及内核态与用户态的上下文切换，CPU 的开销非常大，因此极大地限制了 OS 高效进行数据传输的能力。

零拷贝技术很好地改善了这个问题：首先在内核驱动程序处理 I/O 数据的时候，它不再需要进行上下文的切换，节省了内核缓冲区与用户态应用程序缓冲区之间的数据拷贝，同时它利用**直接存储器访问技术**（Direct Memory Access, DMA）执行 I/O 操作，因此也避免了 OS 内核缓冲区之间的数据拷贝，故而得名零拷贝。

Linux 提供的 sendfile 系统调用实现了这种零拷贝技术，而 Kafka 的消息消费机制使用的就是 sendfile —— 严格来说是通过 Java 的 `FileChannel.transferTo` 方法实现的。

除了零拷贝技术，Kafka 由于大量使用页缓存，故读取消息时大部分消息很有可能依然保存在页缓存中，因此可以直接命中缓存，不用“穿透”到底层的物理磁盘上获取消息，从而极大地提升了消息读取的吞吐量。事实上，如果我们监控一个经过良好调优的 Kafka 生产集群便可以发现，即使是那些有负载的 Kafka 服务器，其磁盘的读操作也很少，这是因为大部分的消息读取操作会直接命中页缓存。

# 4 小结

总结一下，Kafka 就是依靠下列 4 点达到了高吞吐量、低延时的设计目标的：

- 大量使用操作系统页缓存，内存操作系统速度快且命中率高
- Kafka 不直接参与物理 I/O 操作，而是交由最擅长此事的操作系统来完成。
- 采用追加写入方式，摒弃了缓慢的磁盘随机读/写操作。
- 使用以 sendfile 为代表的零拷贝技术加强网络间的数据传输效率。

# 参考文档

- 《Apache Kafka 实战》1.3.1 吞吐量/延时
