# 等效面试题

- Java 中方法参数只有值传递吗？

- 分析一下 Java 方法参数的值传递和引用传递

# 简答

Java 程序设计语言**总是**采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。

Java 中方法参数的使用情况：

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

所以需要注意：包装器类也不可以用来实现修改数值参数的方法。

# 详解

首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。**按值调用**（call by value）表示方法接收的是调用者提供的值。而按**引用调用**（call by reference）表示方法接收的是调用者提供的变量**地址**。一个方法可以**修改**传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。“**按……调用**”（call by）是一个标准的计算机科学术语，它用来描述各种程序设计语言（不只是 Java）中方法参数的传递方式

> 事实上，以前还有**按名调用**（call by name），Algol 程序设计语言是最古老的高级程序设计语言之一，它使用的就是这种参数传递方式。不过，对于今天，这种传递方式已经成为了历史。

Java 程序设计语言**总是**采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。

很多程序设计语言（特别是， C++ 和 Pascal) 提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上， 这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。

首先，编写一个交换两个雇员对象的方法：

~~~java
public static void swap(Employee x, Employee y) {
    Employee temp = x;
    x = y;
    y = temp;
}
~~~

如果 Java 对对象采用的是按引用调用，那么这个方法就应该能够实现交换数据的效果：

~~~java
Employee a = new Employee("Alice", ...);
Employee b = new Employee("Bob", ...);
swap(a, b);
~~~

但是方法并没有改变存储在变量 a 和 b 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。

最终，白费力气。在方法结束时参数变量 x 和 y 被丢弃了。原来的变量 a 和 b 仍然引用这个方法调用之前所引用的对象。

Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。

下面总结一下 Java 中方法参数的使用情况：

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

## 包装器类的值传递

有些人认为包装器类可以用来实现修改数值参数的方法，然而这是错误的。由于 Java 方法都是值传递，所以不可能编写一个下面这样的能够增加整型参数值的 Java 方法。

~~~java
public static void triple(int x) {
    x = 3 * x;
}
~~~

将 int 替换成 Integer 又会怎样呢？

问题是 Integer 对象是不可变的：包含在包装器中的内容不会改变。不能使用这些包装器类创建修改数值参数的方法。

> 看网上的博客，也可以用反射去修改 Integer 对象内部的值。但感觉这样就违背了 Integer 设计的初衷，所以具体请自行查询如何实现。

如果想编写一个修改数值参数值的方法，就需要使用在 org.omg.CORBA 包中定义的持有者（holder）类型，包括 IntHolder、BooleanHolder 等。每个持有者类型都包含一个公有域值，通过它可以访问存储在其中的值。

# 参考文档

- 《Java 核心技术：卷一 基础知识》（第 10 版）4.5 方法参数、5.4 对象包装器与自动装箱