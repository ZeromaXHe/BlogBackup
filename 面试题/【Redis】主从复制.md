# 简答

在 Redis 中，用户可以通过执行 SLAVEOF 命令或者设置 slaveof 选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。

进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。

Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足**一致性**要求。当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足**可用性**。

Redis 保证**最终一致性**，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。

## 旧版复制实现

Redis 的复制功能分为**同步**（sync）和**命令传播**（command propagate）两个操作：

- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

**从服务器对主服务器的同步操作需要通过向主服务器发送 `SYNC` 命令来完成**，以下是 `SYNC` 命令的执行步骤：

1. 从服务器向主服务器发送 `SYNC` 命令。
2. 收到 `SYNC` 命令的主服务器执行 `BGSAVE` 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写部分。
3. 当主服务器的 `BGSAVE` 命令执行完毕时，主服务器会将 `BGSAVE` 命令生成的 RDB 文件发送给从服务器，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至主服务器执行 `BGSAVE` 命令时的数据库状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。**为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作**：主服务器会将自己执行的写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

对于**初次复制**来说，旧版复制功能能够很好地完成任务，但对于**断线后重复制**来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。

## 新版复制实现

为了解决旧版复制功能在处理断线重复制情况时的低效问题，**Redis 从 2.8 版本开始，使用 `PSYNC` 命令代替 `SYNC` 命令来执行复制时的同步操作**。

`PSYNC` 命令具有**完整重同步**（full resynchronization）和**部分重同步**（partial resynchronization）两种模式：

- 其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和 `SYNC` 命令的执行步骤基本一样，它们都是通过让主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
- 而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

`PSYNC` 命令的部分重同步模式解决了旧版复制功能在处理断线后重复制时出现的低效情况。

1. 主从服务器重新连接
2. 从服务器向主服务器发送 `PSYNC` 命令
3. 主服务器向从服务器返回 `+CONTINUE` 回复，表示执行部分重同步
4. 从服务器接收 `+CONTINUE` 回复，准备执行部分重同步
5. 主服务器向从服务器发送断线后的命令，从服务器接收并执行传来的命令
6. 主从服务器再次完成同步

对比一下 `SYNC` 命令和 `PSYNC` 命令处理断线重复制的方法，不难看出，虽然 `SYNC` 命令和 `PSYNC` 命令都可以让断线的主从服务器重新回到一致状态，但执行部分重同步所需的资源比起执行 `SYNC` 命令所需的资源要少得多，完成同步的速度也快得多。执行 `SYNC` 命令需要生成、传送和载入整个 RDB 文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了。

## 复制的步骤

1. **设置主服务器的地址和端口**：`SLAVEOF` 命令是一个异步命令，在完成 `masterhost` 属性和 `masterport` 属性的设置工作之后，从服务器将向发送 `SLAVEOF` 命令的客户端返回 OK，表示复制指令已经被接收
2. **建立套接字连接**：在 `SLAVEOF` 命令执行之后，从服务器将根据命令所设置的 IP 地址和端口，创建连向主服务器的套接字连接。而主服务器在接受（accept）从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待。
3. **发送 PING 命令**：如果从服务器设置了 `masterauth` 选项，那么进行身份验证。
4. **身份验证**：在身份验证步骤之后，从服务器将执行命令 `REPLCONF listening-port <port-number>`，向主服务器发送从服务器的监听端口号。
5. **同步**：在这一步，从服务器将向主服务器发送 `PSYNC` 命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端。
6. **命令传播**：当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。

# 详解

很多企业都没有使用到 Redis 的集群，但是至少都做了主从。有了主从，当 master 挂掉的时候，运维让从库过来接管，服务就可以继续，否则 master 需要经过数据恢复和重启的过程，这就可能会拖很长的时间，影响线上业务的持续服务。

在 Redis 中，用户可以通过执行 SLAVEOF 命令或者设置 slaveof 选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。

假设现在有两个 Redis 服务器，地址分别为 127.0.0.1:6379 和 127.0.0.1:12345，如果我们向服务器 127.0.0.1:12345 发送以下命令：

```sh
127.0.0.1:12345> SLAVEOF 127.0.0.1 6379
OK
```

那么服务器 127.0.0.1:12345 将成为 127.0.0.1:6379 的从服务器，而服务器 127.0.0.1:6379 则会成为 127.0.0.1:12345 的主服务器。

进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。

## 1 相关概念简介

### 1.1 CAP 原理

在了解 Redis 的主从复制之前，让我们先来理解一下现代分布式系统的理论基石——CAP 原理。CAP 原理是分布式存储的理论基石。

- **C** - **C**onsistent ，一致性
- **A** - **A**vailability ，可用性
- **P** - **P**artition tolerance ，分区容忍性

分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫做**网络分区**。

在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的**一致性**将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲**可用性**，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。

一句话概括 CAP 原理就是——**网络分区发生时，一致性和可用性两难全**。

### 1.2 最终一致

Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足**一致性**要求。当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足**可用性**。

Redis 保证**最终一致性**，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。

### 1.3 主从同步

Redis 同步支持主从同步和从从同步，从从同步功能是 Redis 后续版本增加的功能，为了减轻主库的同步负担。后面为了描述上的方便，统一理解为主从同步。

### 1.4 增量同步

Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一遍向主节点反馈自己同步到哪里了 (偏移量)。

因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer 中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。

如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制——快照同步。

### 1.5 快照同步

快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完毕后通知主节点继续进行增量同步。

在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。

所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。

### 1.6 增加从节点

当从节点刚刚加入到集群时，它必须先要进行一次快照同步，同步完成后再继续进行增量同步。

### 1.7 无盘复制

主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。

所以从 Redis 2.8.18 版开始支持无盘复制。所谓**无盘复制**是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一边将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。

### 1.8 Wait 指令

Redis 的复制是异步进行的，**wait 指令**可以让异步复制变身同步复制，确保系统的强一致性 (不严格)。wait 指令是 Redis3.0 版本以后才出现的。

wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 t，以毫秒为单位。它表示等待 wait 指令之前的所有写操作同步到 N 个从库 (也就是确保 N 个从库的同步没有滞后)，最多等待时间 t。如果时间 t=0，表示无限等待直到 N 个从库同步完成达成一致。

## 2 旧版复制功能的实现

Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：

- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

### 2.1 同步

当客户端向从服务器发送 `SLAVEOF` 命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。

从服务器对主服务器的同步操作需要通过向主服务器发送 `SYNC` 命令来完成，以下是 `SYNC` 命令的执行步骤：

1. 从服务器向主服务器发送 `SYNC` 命令。
2. 收到 `SYNC` 命令的主服务器执行 `BGSAVE` 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写部分。
3. 当主服务器的 `BGSAVE` 命令执行完毕时，主服务器会将 `BGSAVE` 命令生成的 RDB 文件发送给从服务器，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至主服务器执行 `BGSAVE` 命令时的数据库状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

### 2.2 命令传播

在同步操作执行完成之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。

为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

### 2.3 旧版复制功能的缺陷

在 Redis 中，从服务器对主服务器的复制可以分为以下两种情况：

- 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。
- 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。

对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。

要理解这一情况，请看下表展示的断线后重复制例子。

| 时间   | 主服务器                                                     | 从服务器                                                     |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| T0     | 主从服务器完成同步                                           | 主从服务器完成同步                                           |
| T1     | 执行并传播 `SET k1 v1`                                       | 执行主服务器传来的 `SET k1 v1`                               |
| T2     | 执行并传播 `SET k2 v2`                                       | 执行主服务器传来的 `SET k2 v2`                               |
| …      | …                                                            | …                                                            |
| T10085 | 执行并传播 `SET k10085 v10085`                               | 执行主服务器传来的 `SET k10085 v10085`                       |
| T10086 | 执行并传播 `SET k10086 v10086`                               | 执行主服务器传来的 `SET k10085 v10086`                       |
| T10087 | 主从服务器连接断开                                           | 主从服务器连接断开                                           |
| T10088 | 执行 `SET k10087 v10087`                                     | 断线中，尝试重新连接主服务器                                 |
| T10089 | 执行 `SET k10088 v10088`                                     | 断线中，尝试重新连接主服务器                                 |
| T10090 | 执行 `SET k10089 v10089`                                     | 断线中，尝试重新连接主服务器                                 |
| T10091 | 主从服务器重新连接                                           | 主从服务器重新连接                                           |
| T10092 |                                                              | 向主服务器发送 `SYNC` 命令                                   |
| T10093 | 接收到从服务器发来的 `SYNC` 命令，执行 `BGSAVE` 命令，创建包含键 `k1` 至键 `k10089` 的 RDB 文件，并使用缓冲区记录接下来执行的所有写命令 |                                                              |
| T10094 | `BGSAVE` 命令执行完毕，向从服务器发送 RDB 文件               |                                                              |
| T10095 |                                                              | 接收并载入主服务器发来的 RDB 文件，获得键 `k1` 至键 `k10089` |
| T10096 | 因为在 `BGSAVE` 命令执行期间，主服务器没有执行任何写命令，所以跳过发送缓冲区包含的写命令这一步 |                                                              |
| T10097 | 主从服务器再次完成同步                                       | 主从服务器再次完成同步                                       |

在时间 T10091，从服务器终于重新连接上主服务器，因为此时主从服务器的状态已经不再一致，所以从服务器将向主服务器发送 `SYNC` 命令，而主服务器会将包含键 `k1` 至键 `k10089` 的 RDB 文件发送给从服务器，从服务器通过接收和载入这个 RDB 文件来将自己的数据库更新至主服务器数据库当前所处的状态。

虽然再次发送 `SYNC` 命令可以让主从服务器重新回到一致状态，但如果我们仔细研究这个断线重复制过程，就会发现传送 RDB 文件这一步实际上并不是非做不可的：

- 主从服务器在时间 T0 至时间 T10086 中一直处于一致状态，这两个服务器保存的数据大部分都是相同的。
- 从服务器想要将自己更新至主服务器当前所处的状态，真正需要的是主从服务器连接中断期间，主服务器新添加的 `k10087`、`k10088`、`k10089` 三个键的数据
- 可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键 `k1` 至键 `k10089` 的 RDB 文件，但实际上 RDB 文件包含的键 `k1` 至键 `k10086` 的数据对于从服务器来说都是不必要的。

上面给出的例子可能有一点理想化，因为在主从服务器断线期间，主服务器执行的写命令可能会有成百上千个之多，而不仅仅是两三个写命令。但总的来说，主从服务器断开的时间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，**在这种情况下，为了让从服务器补足一小部分缺失的数据，却要让主从服务器重新执行一次 `SYNC` 命令，这种做法无疑是非常低效的**。

> **SYNC 命令是一个非常耗费资源的操作**
>
> 每次执行 `SYNC` 命令，主从服务器需要执行以下动作：
>
> 1. 主服务器需要执行 `BGSAVE` 命令来生成 RDB 文件，这个生成操作会耗费主服务器大量的 CPU、内存和磁盘 I/O 资源。
> 2. 主服务器需要将自己生成的 RDB 文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。
> 3. 接收到 RDB 文件的从服务器需要载入主服务器发来的 RDB 文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。
>
> 因为 `SYNC` 命令是一个如此耗费资源的操作，所以 Redis 有必要保证在真正有需要时才执行 `SYNC` 命令。

## 3 新版复制功能的实现

为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis 从 2.8 版本开始，使用 `PSYNC` 命令代替 `SYNC` 命令来执行复制时的同步操作。

`PSYNC` 命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：

- 其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和 `SYNC` 命令的执行步骤基本一样，它们都是通过让主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
- 而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

`PSYNC` 命令的部分重同步模式解决了旧版复制功能在处理断线后重复制时出现的低效情况。

1. 主从服务器重新连接
2. 从服务器向主服务器发送 `PSYNC` 命令
3. 主服务器向从服务器返回 `+CONTINUE` 回复，表示执行部分重同步
4. 从服务器接收 `+CONTINUE` 回复，准备执行部分重同步
5. 主服务器向从服务器发送断线后的命令，从服务器接收并执行传来的命令
6. 主从服务器再次完成同步

对比一下 `SYNC` 命令和 `PSYNC` 命令处理断线重复制的方法，不难看出，虽然 `SYNC` 命令和 `PSYNC` 命令都可以让断线的主从服务器重新回到一致状态，但执行部分重同步所需的资源比起执行 `SYNC` 命令所需的资源要少得多，完成同步的速度也快得多。执行 `SYNC` 命令需要生成、传送和载入整个 RDB 文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了。

### 3.1 部分重同步的实现

部分重同步功能由以下三个部分构成：

- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。
- 主服务器的复制积压缓冲区（replication backlog）。
- 服务器的运行 ID（run ID）

#### 3.1.1 复制偏移量

执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：

- 主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N。
- 从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N。

通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态：

- 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的。
- 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。

#### 3.1.2 复制积压缓冲区

复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为 1MB。

当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。

因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。

当从服务器重新连上主服务器时，从服务器会通过 `PSYNC` 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：

- 如果 offset 偏移量之后的数据（也即是偏移量 offset + 1 开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。
- 相反，如果 offset 偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。

回到之前展示的断线后重连接的例子：

- 当从服务器 A 断线后，它立即重新连接主服务器，并向主服务器发送 `PSYNC` 命令，报告自己的复制偏移量为 10086。
- 主服务器收到从服务器发来的 `PSYNC` 命令以及偏移量 10086 之后，主服务器将检查偏移量 10086 之后的数据是否存在于复制积压缓冲区里面，结果发现这些数据仍然存在，于是主服务器向从服务器发送 `+CONTINUE` 回复，表示数据同步将以部分重同步模式来进行。
- 接着主服务器会将复制积压缓冲区 10086 偏移量之后的所有数据（偏移量为 10087 至 10119）都发送给从服务器。
- 从服务器只要接收这 33 字节的缺失数据，就可以回到与主服务器一致的状态。

> **根据需要调整复制积压缓冲区的大小**
>
> Redis 为复制积压缓冲区设置的默认大小为 1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大小设置得不恰当，那么 `PSYNC` 命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。
>
> 复制积压缓冲区的最小大小可以根据公式 `second * write_size_per_second` 来估算：
>
> - 其中 `second` 为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）。
> - 而 `write_size_per_second` 则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。
>
> 为了安全起见，可以将复制积压缓冲区的大小设为 `2 * second * write_size_per_second`，这样可以保证绝大部分断线情况都能用部分重同步来处理。
>
> 至于复制积压缓冲区大小的修改方法，可以参考配置文件中关于 `repl-backlog-size` 选项的说明。

#### 3.1.3 服务器运行 ID

除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行 ID（run ID）：

- 每个 Redis 服务器，不论主服务器还是从服务，都会有自己的运行 ID。
- 运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制字符组成。

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器，而从服务器则会将这个运行 ID 保存起来。

当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行 ID：

- 如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。
- 相反地，如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。

### 3.2 PSYNC 命令的实现

`PSYNC` 命令的调用方法有两种：

- 如果从服务器以前没有复制过任何主服务器，或者之前执行过 `SLAVEOF no one`，那么从服务器在开始一次新的复制时将向主服务器发送 `PSYNC ? -1` 命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）。
- 相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 `PSYNC <runid> <offset>` 命令：其中 `runid` 是上一次复制的主服务器的运行 ID，而 `offset` 则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。

根据情况，接收到 `PSYNC` 命令的主服务器会向从服务器返回以下三种回复的其中一种：

- 如果主服务器返回 `+FULLRESYNC <runid> <offset>` 回复，那么表示主服务器将与从服务器执行完整重同步操作：其中 `runid` 是这个主服务器的运行 ID，从服务器会将这个 ID 保存起来，在下一次发送 `PSYNC` 命令时使用；而 `offset` 则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。
- 如果主服务器返回 `+CONTINUE` 回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。
- 如果主服务器返回 `-ERR` 回复，那么表示主服务器的版本低于 Redis 2.8，它识别不了 `PSYNC` 命令，从服务器将向主服务器发送 `SYNC` 命令，并与主服务器执行完整同步操作。

## 4 复制的实现

通过向从服务器发送 `SLAVEOF` 命令，我们可以让一个从服务器去复制一个主服务器：

```sh
SLAVEOF <master_ip> <master_port>
```

本节将以从服务器 127.0.0.1:12345 接收到命令：

```sh
SLAVEOF 127.0.0.1 6379
```

为例，展示 Redis 2.8 或以上版本的复制功能的详细实现步骤。

### 4.1 步骤1：设置主服务器的地址和端口

当客户端向从服务器发送以下命令时：

```sh
127.0.0.1:12345> SLAVEOF 127.0.0.1 6379
OK
```

从服务器首先要做的就是将客户端给定的主服务器 IP 地址 127.0.0.1 以及端口 6379 保存到服务器状态的 masterhost 属性和 masterport 属性里面：

```c
struct redisServer {
    // ...
    // 主服务器的地址
    char *masterhost;
    // 主服务器的端口
    int masterport;
    // ...
};
```

`SLAVEOF` 命令是一个异步命令，在完成 `masterhost` 属性和 `masterport` 属性的设置工作之后，从服务器将向发送 `SLAVEOF` 命令的客户端返回 OK，表示复制指令已经被接收，而实际的复制工作将在 OK 返回之后才真正开始执行。

### 4.2 步骤2：建立套接字连接

在 `SLAVEOF` 命令执行之后，从服务器将根据命令所设置的 IP 地址和端口，创建连向主服务器的套接字连接。

如果从服务器创建的套接字能成功连接（connect）到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收 RDB 文件，以及接收主服务器传播来的写命令，诸如此类。

而主服务器在接受（accept）从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复。

因为复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进行，所以理解“从服务器是主服务器的客户端”这一点非常重要。

### 4.3 步骤3：发送 PING 命令

从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个 PING 命令。

这个 PING 命令有两个作用：

- 虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信，通过发送 PING 命令可以检查套接字的读写状态是否正常。
- 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送 PING 命令可以检查主服务器能否正常处理命令请求。

从服务器在发送 PING 命令之后将遇到以下三种情况的其中一种：

- 如果主服务器向从服务器返回了一个命令回复，但从服务器却不能在规定的时限（timeout）内读取出命令回复的内容，那么表示主从服务器之间的网络连接状态不佳，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建连向主服务器的套接字。
- 如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。当出现这种情况时，从服务器断开并重新创建连向主服务器的套接字。比如说，如果主服务器正在处理一个超时运行的脚本，那么当从服务器向主服务器发送 PING 命令时，从服务器将收到主服务器返回的 `BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.` 错误。
- 如果从服务器读取到“`PONG`”回复，那么表示主从服务器之间的网络连接状态正常，并且主服务器可以正常处理从服务器（客户端）发送的命令请求，在这种情况下，从服务器可以继续执行复制工作的下个步骤。

### 4.4 步骤4：身份验证

从服务器在收到主服务器返回的“`PONG`”回复之后，下一步要做的就是决定是否进行身份验证：

- 如果从服务器设置了 `masterauth` 选项，那么进行身份验证。
- 如果从服务器没有设置 `masterauth` 选项，那么不进行身份验证。

在需要进行身份验证的情况下，从服务器将向主服务器发送一条 `AUTH` 命令，命令的参数为从服务器 `masterauth` 选项的值。

举个例子，如果从服务器 `masterauth` 选项的值为 10086，那么从服务器将向主服务器发送命令 `AUTH 10086`。

从服务器在身份验证阶段可能遇到的情况有以下几种：

- 如果主服务器没有设置 `requirepass` 选项，并且从服务器也没有设置 `masterauth` 选项，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续进行。
- 如果从服务器通过 `AUTH` 命令发送的密码和主服务器 `requirepass` 选项所设置的密码相同，那么主服务器设置的密码不相同，那么主服务器将返回一个 `invalid password` 错误。
- 如果主服务器设置了 `requirepass` 选项，但从服务器却没有设置 `masterauth` 选项，那么主服务器将返回一个 `NOAUTH` 错误。另一方面，如果主服务器没有设置 `requirepass` 选项，但从服务器却设置了 `masterauth` 选项，那么主服务器将返回一个 `no password is set` 错误。

所有错误情况都会令从服务器中止目前的复制工作，并从创建套接字开始重新执行复制，直到身份验证通过，或者从服务器放弃执行复制为止。

### 4.5 步骤5：发送端口信息

在身份验证步骤之后，从服务器将执行命令 `REPLCONF listening-port <port-number>`，向主服务器发送从服务器的监听端口号。

主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的 `slave_listening_port` 属性中：

```c
typedef struct redisClient {
    // ...
    // 从服务器的监听端口号
    int slave_listening_port;
    // ...
} redisClient;
```

`slave_listening_port` 属性目前唯一的作用就是在主服务器执行 `INFO replication` 命令时打印出从服务器的端口号。

### 4.6 步骤6：同步

在这一步，从服务器将向主服务器发送 `PSYNC` 命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。

值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端。

- 如果 `PSYNC` 命令执行的是完整重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。
- 如果 `PSYNC` 命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令。

因此，在同步操作执行之后，主从服务器双方都是对方的客户端，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复。

正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命令传播操作的基础。

### 4.7 步骤7：命令传播

当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。

以上就是 Redis 2.8 或以上版本的复制功能的实现步骤。

# 参考文档

- 《Redis 深度历险：核心原理和应用实践》原理 8：有备无患——主从同步
- 《Redis 设计与实现》第 15 章 复制