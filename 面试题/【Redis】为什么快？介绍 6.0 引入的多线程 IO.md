# 简答

Redis 执行命令速度快，读写性能可以达到 10 万/秒，主要原因如下：

- Redis 的**所有数据都是存放在内存中**的，内存的响应时长大约为 100 纳秒，这是 Redis 达到每秒万级别访问的重要基础。
- Redis 是用 **C 语言**实现的，一般来说 C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。
- Redis 使用了**单线程架构**，预防了多线程可能产生的竞争问题，避免了线程切换和竞态产生的消耗。
- 在网络 I/O 层面，Redis 使用了**非阻塞 I/O**，Redis 使用 epoll 作为 I/O 多路复用技术的实现。6.0 后更是引入了多线程 I/O。



**介绍 6.0 引入的多线程 I/O**

首先强调：Redis 6.0 引入**多线程 I/O**，只是用来**处理网络数据的读写和协议的解析**，而**执行命令依旧是单线程**

`服务器 → 主线程 → ae 模块 -(read 监听)→ 多个工作线程 -(就绪监听)→ 主线程 → 执行命令`

流程如下：

- 主线程获取 socket 放入等待列表
- 将 socket 分配给各个 I/O 线程（并不会等列表满）
- 主线程**阻塞**等待 **I/O 线程（多线程）**读取 socket 完毕
- 主线程执行命令 - **单线程**（如果命令没有接收完毕，会等 I/O 下次继续）
- 主线程**阻塞**等待 **I/O 线程（多线程）**将数据回写 socket 完毕（一次没写完，会等下次再写）
- 解除绑定，清空等待队列

特点如下：

- I/O 线程要么同时在读 socket，要么同时在写，不会同时读或写
- I/O 线程只负责读写 socket 解析命令，不负责命令处理（主线程串行执行命令）
- I/O 线程数可自行配置

# 详解

正常情况下，Redis 执行命令的速度非常快，官方给出的数字是读写性能可以达到 10 万/秒，当然这也取决于机器的性能，但这里先不讨论机器性能上的差异，只分析一下是什么造就了Redis除此之快的速度，可以大致归纳为以下四点：

- Redis 的所有数据都是存放在内存中的，**把数据放在内存中是Redis速度快的最主要原因**。
- Redis 是用 **C 语言**实现的，一般来说 C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。 
- Redis 使用了**单线程架构**，预防了多线程可能产生的竞争问题。 
- 作者对于 Redis 源代码可以说是精打细磨，曾经有人评价 Redis 是少有的**集性能和优雅于一身的开源代码**。

# 1 单线程架构

Redis 使用了单线程架构和 I/O 多路复用模型来实现高性能的内存数据库服务。

## 1.1 引出单线程模型

Redis客户端与服务端的模型可以简化成：每次客户端调用都经历了发送命令、执行命令、返回结果三个过程。 

其中第 2 步是重点要讨论的，因为 Redis 是单线程来处理命令的，所以一条命令从客户端达到服务端不会立刻被执行，所有命令都会进入一个队列中，然后逐个被执行。所以上面 3 个客户端命令的执行顺序是不确定的，但是可以确定不会有两条命令被同时执行， 所以两条 incr 命令无论怎么执行最终结果都是 2，不会产生并发问题，这就是 Redis 单线程的基本模型。但是像发送命令、返回结果、命令排队肯定不像描述的这么简单，Redis 使用了 I/O 多路复用技术来解决 I/O 的问题。

## 1.2 为什么单线程还能这么快

通常来讲，单线程处理能力要比多线程差，那么为什么 Redis 使用单线程模型会达到每秒万级别的处理能力呢？可以将其归结为三点： 

- 第一，**纯内存访问**，Redis 将所有数据放在内存中，内存的响应时长大约为 100 纳秒，这是 Redis 达到每秒万级别访问的重要基础。 
- 第二，**非阻塞 I/O**，Redis 使用 epoll 作为 I/O 多路复用技术的实现，再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多的时间。 
- 第三，单线程**避免了线程切换和竞态产生的消耗**。

既然采用单线程就能达到如此高的性能，那么也不失为一种不错的选择，因为单线程能带来几个好处：

- 第一，单线程可以简化数据结构和算法的实现。如果对高级编程语言熟悉的读者应该了解并发数据结构实现不但困难而且开发测试比较麻烦。
- 第二，单线程避免了线程切换和竞态产生的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。 

但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于 Redis 这种高性能的服务来说是致命的，所以 Redis 是面向快速执行场景的数据库。

> **什么是非阻塞 I/O？**
>
> 非阻塞 I/O 在 Socket 对象上提供了一个选项 `Non_Blocking` ，当这个选项打开时，读写方法不会阻塞，而是能读多少读多少，能写多少写多少。
>
> 能读多少取决于内核为 Socket 分配的读缓冲区的大小，能写多少取决于内核为 Socket 分配的写缓冲区的剩余空间大小。读方法和写方法都会通过返回值来告知程序实际读写了多少字节数据。
>
> 有了非阻塞 I/O 意味着线程在读写 I/O 时可以不必再阻塞了，读写可以瞬间完成然后线程可以继续干别的事了。

> **什么是 I/O 多路复用？**
>
> 非阻塞 I/O 有个问题，那就是单个线程要处理多个读写请求，处理某个客户端的的读数据的请求，结果读了一部分就返回了，线程如何知道什么时候才应该继续读数据。处理写请求的时候，如果缓冲区满了，写不完，剩下的数据何时才应该继续写？在什么时候处理什么请求？redis 单线程处理多个 I/O 请求时就用到了 I/O 多路复用技术。
>
> 例如，redis 需要处理 3 个 I/O 请求，同时把 3 个请求的结果返回给客户端，所以总共需要处理 6 个 I/O 事件，由于 redis 是单线程模型，同一时间只能处理一个 I/O 事件，于是 redis 需要在合适的时间暂停对某个 I/O 事件的处理，转而去处理另一个 I/O 事件，这样 redis 就好比一个开关，当开关拨到哪个 I/O 事件这个电路上，就处理哪个 I/O 事件，其他 I/O 事件就暂停处理了。这就是 I/O 多路复用技术。
>
> 以上是大致的理解下 I/O 多路复用技术，在系统底层，I/O 多路复用有 3 种实现机制：select、poll、epoll。

关于 I/O 多路复用的详细内容，还可以参考我总结的面试题解答： [IO 复用：select、poll、epoll 系统调用](./【Linux】IO 复用：select、poll、epoll 系统调用.md)

# 2 Redis 6.0 后的多线程 I/O

>  首先强调：Redis 6.0 引入**多线程 I/O**，只是用来**处理网络数据的读写和协议的解析**，而**执行命令依旧是单线程**

众所周知，Redis 之前的版本一直都是典型的单线程模型（注意：这里不是指 Redis 单实例中只有一个线程，而是表示核心操作模块由单线程完成，当然另外还有一些辅助线程从旁协助，比如 LRU 的淘汰过程），为什么不使用多线程呢，其实原因很简单：

- 根据以往的场景，普通 KV 存储瓶颈压根不在 CPU，而往往可能受到内存和网络 I/O 的制约
- Redis 中有各种类型的数据操作，甚至包括一些事务处理，如果采用多线程，则会被多线程产生的切换问题而困扰，也可能因为加锁导致系统架构变的异常复杂，更有可能会因为加锁解锁甚至死锁造成的性能损耗

当然，单线程也会有不能充分利用多核资源弊端，这是一个权衡；而通常 Redis（包括 Redis cluster）的性能已经足够我们使用。

那么，既然单线程都已经基本能满足场景，更不要说还能开启多实例、上集群等方式，那么为什么还要费力引入多线程呢？

## 2.1 引入多线程

上面提到，瓶颈往往在内存和网络 I/O

**内存**方面毋容置疑，加就是了，虽然需要注意 NUMA 陷阱，但是也不是不能解决；

> **NUMA** 全称 Non-Uniform Memory Access，译为“非一致性内存访问”。这种构架下，不同的内存器件和CPU核心从属不同的 Node，每个 Node 都有自己的集成内存控制器（IMC，Integrated Memory Controller）。在 Node 内部，架构类似SMP，使用 IMC Bus 进行不同核心间的通信；不同的 Node 间通过 **QPI**（Quick Path Interconnect）进行通信。
>
> 一般来说，一个内存插槽对应一个 Node。需要注意的一个特点是，QPI 的延迟要高于 IMC Bus，也就是说 CPU 访问内存有了远近（remote/local）之别，而且实验分析来看，这个差别非常明显。
>
> NUMA 是一种用于多处理器的电脑内存体设计，内存访问时间取决于处理器的内存位置。 在NUMA下，处理器访问它自己的本地存储器的速度比非本地存储器（存储器的地方到另一个处理器之间共享的处理器或存储器）快一些。
>
> **NUMA 陷阱**指的是引入 QPI 总线后，在计算机系统里可能会存在的一个坑。大致的意思就是如果你的机器打开了 NUMA，那么你的内存即使在充足的情况下，也会使用磁盘上的 swap，导致性能低下。原因就是 NUMA 为了高效，会仅仅只从你的当前 node 里分配内存，只要当前 node 里用光了（即使其它 node 还有），也仍然会启用硬盘 swap。

那么能不能对 **网络I/O** 进行进一步优化从而减少消耗呢，通常做法是： 

- 采用 DPDK 从内核层对网络处理流程模块进行优化（因为需要特殊支持，所以显得不那么大众）
- 利用多核优势，使用多线程充分利用多核，典型的实现比如 Memcached

协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。于是 Redis 开发组的各位大佬们就想到能不能通过支持多线程这一简单惠民的方式进行解决（这里也体现了大佬们对性能的极限追求），于是就有了下面的架构（以 Read 为例）

`服务器 → 主线程 → ae 模块 -(read 监听)→ 多个工作线程 -(就绪监听)→ 主线程 → 执行命令`

流程如下：

- 主线程获取 socket 放入等待列表
- 将 socket 分配给各个 I/O 线程（并不会等列表满）
- 主线程**阻塞**等待 **I/O 线程（多线程）**读取 socket 完毕
- 主线程执行命令 - **单线程**（如果命令没有接收完毕，会等 I/O 下次继续）
- 主线程**阻塞**等待 **I/O 线程（多线程）**将数据回写 socket 完毕（一次没写完，会等下次再写）
- 解除绑定，清空等待队列

根据上方结构可以看到，Redis 6 中的多线程主要在处理网络 I/O 方面，对网络事件进行监听，分发给多个工作线程进行处理，处理完以后将主动权交还给主线程，进行执行操作，当然后续还会有，执行后依然交由工作线程进行响应数据的 socket write 操作

特点如下：

- I/O 线程要么同时在读 socket，要么同时在写，不会同时读或写
- I/O 线程只负责读写 socket 解析命令，不负责命令处理（主线程串行执行命令）
- I/O 线程数可自行配置

# 参考文档

- 《Redis 开发与运维》1.2 Redis 特性、2.1.3 单线程架构
- Redis6 多线程剖析：https://zhuanlan.zhihu.com/p/118450227
- 浅解 NUMA 机制：https://www.jianshu.com/p/0607c5f62c51
- 挑战 Redis 单实例内存最大极限，“遭遇”NUMA陷阱！：https://zhuanlan.zhihu.com/p/95462736
- 第十一节：Redis 6.0 新特性、剖析线程模型(单线程和多线程)：https://www.cnblogs.com/yaopengfei/p/13946966.html