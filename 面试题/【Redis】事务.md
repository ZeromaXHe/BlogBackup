# 简答

Redis 事务主要依赖于一些命令：**multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃**。所有的指令在 exec 之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为 Redis 的单线程特性，它不用担心自己在执行队列的时候被其它指令打搅，可以保证他们能得到不中断的执行。

此外还有 **watch 指令来提供类似乐观锁的作用**。watch 会在事务开始之前盯住 1 个或多个关键变量，当事务执行时，也就是服务器收到了 exec 指令要顺序执行缓存的事务队列时，Redis 会检查关键变量自 watch 之后，是否被修改了 (包括当前事务所在的客户端)。如果关键变量被人动过了，exec 指令就会返回 null 回复告知客户端事务执行失败，这个时候客户端一般会选择重试。

Redis 提供了简单的事务，之所以说它简单，主要是因为**它不支持事务中的回滚特性**，同时无法实现命令之间的逻辑关系计算。

- 在命令输入语法错误时，会造成整个事务无法执行
- 在运行时错误时，其他指令会正常执行

一个事务从开始到结束通常会经历以下三个阶段：

1. **事务开始**：MULTI 命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的 flags 属性中打开 `REDIS_MULTI` 标识来完成的。
2. **命令入队**：如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。与此相反，如果客户端发送的命令是上面四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复。
3. **事务执行**：当一个处于事务状态的客户端向服务器发送 EXEC 命令时，这个 EXEC 命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。

在 Redis 中，事务**在运行时错误时不具有原子性（Atomicity）**，**总是具有一致性（Consistency）和隔离性（Isolation）**，并且当 **Redis 运行在 always 的 AOF 持久化模式下时，事务具有较高的耐久性（Durability）但仍可能丢失一个事件循环的命令**。

> 其中，关于原子性、隔离性、耐久性（其实就是持久性），网络上博客和书籍中的介绍存在争议，读者需要关注详解中具体的讲解，理解 Redis 事务真正的实现原理。这样在面试官意见相左的时候才能有的放矢，阐述清楚自己的观点，表明自己明白 Redis 的实现；而不是死记一个结论。

# 详解

为了确保连续多个操作的原子性，一个成熟的数据库通常都会有事务支持，Redis 也不例外。Redis 的事务使用非常简单，不同于关系数据库，我们无须理解那么多复杂的事务模型，就可以直接使用。不过也正是因为这种简单性，它的事务模型很不严格，这要求我们不能像使用关系数据库的事务一样来使用 Redis。

# 1 Redis 事务的基本使用

每个事务的操作都有 begin、commit 和 rollback，begin 指示事务的开始，commit 指示事务的提交，rollback 指示事务的回滚。

它大致的形式如下：

```java
begin();
try {
    command1();
    command2();
    ...
    commit();
} catch(Exception e) {
    rollback();
}
```

Redis 在形式上看起来也差不多，分别是 multi/exec/discard。multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。

```sh
> multi
OK
> incr books
QUEUED
> incr books
QUEUED
> exec
(integer) 1
(integer) 2
```

上面的指令演示了一个完整的事务过程，所有的指令在 exec 之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为 Redis 的单线程特性，它不用担心自己在执行队列的时候被其它指令打搅，可以保证他们能得到的“原子性”执行（注意这里的引号，后面我们会提到）。

上图显示了以上事务过程完整的交互效果。QUEUED 是一个简单字符串，同 OK 是一个形式，它表示指令已经被服务器缓存到队列里了。

## 1.1 原子性

事务的原子性是指要么事务全部成功，要么全部失败，那么 Redis 事务执行是原子性的么？

下面我们来看一个特别的例子。

```sh
> multi
OK
> set books iamastring
QUEUED
> incr books
QUEUED
> set poorman iamdesperate
QUEUED
> exec
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
> get books
"iamastring"
> get poorman
"iamdesperate"
```

上面的例子是事务执行到中间遇到失败了，因为我们不能对一个字符串进行数学运算，事务在遇到指令执行失败后，后面的指令还继续执行，所以 poorman 的值能继续得到设置。

到这里，你应该明白 **Redis 的事务根本不能算“原子性”，而仅仅是满足了事务的“隔离性”**，隔离性中的串行化——当前执行的事务有着不被其它事务打断的权利。

## 1.2 discard（丢弃）

Redis 为事务提供了一个 discard 指令，用于丢弃事务缓存队列中的所有指令，在 exec 执行之前。

```sh
> get books
(nil)
> multi
OK
> incr books
QUEUED
> incr books
QUEUED
> discard
OK
> get books
(nil)
```

我们可以看到 discard 之后，队列中的所有指令都没执行，就好像 multi 和 discard 中间的所有指令从未发生过一样。

## 1.3 优化

上面的 Redis 事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络 IO 时间也会线性增长。所以通常 Redis 的客户端在执行事务时都会结合 pipeline 一起使用，这样可以将多次 IO 操作压缩为单次 IO 操作。

比如我们在使用 Python 的 Redis 客户端时执行事务时是要强制使用 pipeline 的。

```python
pipe = redis.pipeline(transaction=true)
pipe.multi()
pipe.incr("books")
pipe.incr("books")
values = pipe.execute()
```

## 1.4 watch

考虑到一个业务场景，Redis 存储了我们的账户余额数据，它是一个整数。现在有两个并发的客户端要对账户余额进行修改操作，这个修改不是一个简单的 incrby 指令，而是要对余额乘以一个倍数。Redis 可没有提供 multiplyby 这样的指令。我们需要先取出余额然后在内存里乘以倍数，再将结果写回 Redis。

这就会出现并发问题，因为有多个客户端会并发进行操作。我们可以通过 Redis 的分布式锁来避免冲突，这是一个很好的解决方案。分布式锁是一种悲观锁，那是不是可以使用乐观锁的方式来解决冲突呢？

**Redis 提供了这种 watch 的机制，它就是一种乐观锁**。有了 watch 我们又多了一种可以用来解决并发修改的方法。 watch 的使用方式如下：

```python
while True:
	do_watch()
	commands()
	multi()
	send_commands()
	try:
		exec()
		break
	except WatchError:
		continue
```

watch 会在事务开始之前盯住 1 个或多个关键变量，当事务执行时，也就是服务器收到了 exec 指令要顺序执行缓存的事务队列时，Redis 会检查关键变量自 watch 之后，是否被修改了 (包括当前事务所在的客户端)。如果关键变量被人动过了，exec 指令就会返回 null 回复告知客户端事务执行失败，这个时候客户端一般会选择重试。

```sh
> watch books
OK
> incr books # 被修改了
(integer) 1
> multi
OK
> incr books
QUEUED
> exec # 事务执行失败
(nil)
```

当服务器给 exec 指令返回一个 null 回复时，客户端知道了事务执行是失败的，通常客户端 (redis-py) 都会抛出一个 WatchError 这种错误，不过也有些语言 (jedis) 不会抛出异常，而是通过在 exec 方法里返回一个 null，这样客户端需要检查一下返回结果是否为 null 来确定事务是否执行失败。

> **注意事项**
>
> Redis 禁止在 multi 和 exec 之间执行 watch 指令，而必须在 multi 之前做好盯住关键变量，否则会出错。

# 2 事务中命令错误

如果事务中的命令出现错误，Redis 的处理机制也不尽相同

## 2.1 命令错误

例如下面操作错将 set 写成了 sett，属于语法错误，会造成整个事务无法执行，key 和 counter 的值未发生变化：

```sh
127.0.0.1:6388> mget key counter
1) "hello"
2) "100"
127.0.0.1:6388> multi
OK
127.0.0.1:6388> sett key world
(error) ERR unknown command 'sett'
127.0.0.1:6388> incr counter
QUEUED
127.0.0.1:6388> exec
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6388> mget key counter
1) "hello"
2) "100"
```

## 2.2 运行时错误

例如用户 B 在添加粉丝列表时，误把 sadd 命令写成了 zadd 命令，这种就是运行时命令，因为语法是正确的： 

```sh
127.0.0.1:6379> multi
OK
127.0.0.1:6379> sadd user:a:follow user:b
QUEUED
127.0.0.1:6379> zadd user:b:fans 1 user:a
QUEUED
127.0.0.1:6379> exec
1) (integer) 1
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
127.0.0.1:6379> sismember user:a:follow user:b
(integer) 1
```

可以看到 Redis 并不支持回滚功能，`sadd user:a:follow user:b` 命令已经执行成功，开发人员需要自己修复这类问题。

Redis 提供了简单的事务，之所以说它简单，主要是因为它不支持事务中的回滚特性，同时无法实现命令之间的逻辑关系计算，当然也体现了 Redis 的“keep it simple”的特性。

# 3 事务的实现

一个事务从开始到结束通常会经历以下三个阶段：

1. 事务开始
2. 命令入队
3. 事务执行

## 3.1 事务开始

MULTI 命令的执行标志着事务的开始：

```sh
redis> MULTI
OK
```

MULTI 命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的 flags 属性中打开 `REDIS_MULTI` 标识来完成的。

## 3.2 命令入队

当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。

与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：

- 如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。
- 与此相反，如果客户端发送的命令是上面四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复。

## 3.3 事务队列

每个 Redis 客户端都有自己的事务状态，这个事务状态保存在客户端状态的 mstate 属性里面：

```c
typedef struct redisClient {
    // ...
    // 事务状态
    multiState mstate; /* MULTI/EXEC state */
    // ...
} redisClient;
```

事务状态包含一个事务队列，以及一个已入队命令的计数器（也可以说是事务队列的长度）：

```c
typedef struct multiState {
    // 事务队列，FIFO 顺序
    multiCmd *commands;
    // 已入队命令计数
    int count;
} multiState;
```

事务队列是一个 multiCmd 类型的数组，数组中的每个 multiCmd 结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：

```c
typedef struct multiCmd {
    // 参数
    robj **argv;
    // 参数数量
    int argc;
    // 命令指针
    struct redisCommand *cmd;
} multiCmd;
```

事务队列以先进先出（FIFO）的方式保存入队的命令，较先入队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面。

## 3.4 执行事务

当一个处于事务状态的客户端向服务器发送 EXEC 命令时，这个 EXEC 命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。

# 4 WATCH 命令的实现

WATCH 命令是一个乐观锁（optismistic locking），它可以在 EXEC 命令执行之前，监视任意数量的数据库键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。

本节接下来的内容将介绍 WATCH 命令的实现原理，说明事务系统是如何监视某个键，并在键被修改的情况下，确保事务的安全性的。

## 4.1 使用 WATCH 命令监视数据库键

每个 Redis 数据库都保存着一个 `watched_keys` 字典，这个字典的键是某个被 WATCH 命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：

```c
typedef struct redisDb {
    // ...
    // 正在被 WATCH 命令监视的键
    dict *watched_keys;
    // ...
} redisDb;
```

通过 `watched_keys` 字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。

## 4.2 监视机制的触发

所有对数据库进行修改的命令，比如 SET、LPUSH、SADD、ZREM、DEL、FLUSHDB 等等，在执行之后都会调用 `multi.c/touchWatchKey` 函数对 `watched_keys` 字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么 `touchWatchKey` 函数会将监视被修改键的客户端的 `REDIS_DIRTY_CAS` 标识打开，表示该客户端的事务安全性已经被破坏。

## 4.3 判断事务是否安全

当服务器接收到一个客户端发来的 EXEC 命令时，服务器会根据这个客户端是否打开了 `REDIS_DIRTY_CAS` 标识来决定是否执行事务：

- 如果客户端的 `REDIS_DIRTY_CAS` 标识已经被打开，那么说明客户端所监视的键当中，至少有一个键已经被修改过了，在这种情况下，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。
- 如果客户端的 `REDIS_DIRTY_CAS` 标识没有被打开，那么说明客户端监视的所有键都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行客户端提交的这个事务。

# 5 事务的 ACID 性质

在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。

在 Redis 中，事务在运行时错误时不具有原子性（Atomicity），总是具有一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在 always 的 AOF 持久化模式下时，事务具有较高的耐久性（Durability）但仍可能丢失一个事件循环的命令。

## 5.1 原子性

Redis 的事务和传统的关系型数据库事务的最大区别在于，Redis 不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。

Redis 的作者在事务功能的文档中解释说，不支持事务回滚是因为这种复杂的功能和 Redis 追求简单高效的设计主旨不相符，并且他认为，Redis 事务的执行时错误通常都是编程错误产生的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能。

> 总结一下就是 Redis 对原子性的保证是：“要么都运行，要么都不运行”；而不是“要么都正确运行，要么都不运行”。也正因为此，《Redis 设计与实现》原书中认为 Redis 是有原子性的，因为其中对原子性的定义是：**数据库将事务中的多个操作当中一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行**，即只需要满足运行即可，不考虑正确运行。
>
> 但一般情况下，原子性被认为是：全部命令作为一个整体是需要满足同时运行成功或同时运行失败的，即需要有回滚功能，不能有中间状态。所以我这里按照普遍的观点，认为 Redis 事务不具有原子性。

## 5.2 一致性

事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。

Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性。

### 5.2.1 入队错误

如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么 Redis 将拒绝执行这个事务。

因为服务器会拒绝执行入队过程中出现错误的事务，所以 Redis 事务的一致性不会带有入队错误的事务影响。

> **Redis 2.6.5 以前的入队错误处理**
>
> 在 Redis 2.6.5 以前的版本，即使有命令在入队过程中发生了错误，事务一样可以执行，不过被执行的命令只包括那些正确入队的命令。
>
> 因为错误的命令不会被入队，所以 Redis 不会尝试去执行错误的命令，因此，即使在 2.6.5 以前的版本中，Redis 事务的一致性也不会被入队错误影响。

### 5.2.2 执行错误

除了入队时可能发生错误以外，事务还可能在执行的过程中发生错误。

关于这种错误有两个需要说明的地方：

- 执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。
- 即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。

对数据库键执行了错误类型的操作是事务执行期间最常见的错误之一。

因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。

### 5.2.3 服务器停机

如果 Redis 服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现：

- 如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的
- 如果服务器运行在 RDB 模式下，那么在事务中中途停机不会导致不一致性，因为服务器可以根据现有的 RDB 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 RDB 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。
- 如果服务器运行在 AOF 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的 AOF 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 AOF 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。

综上所述，无论 Redis 服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。

## 5.3 隔离性

事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为 Redis 使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis 的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。

> 网上有一些博客认为 Redis 的多客户端事务需要依赖于 WATCH 指令才能保证隔离性，但是我自己读了相关文章和书之后较为认可《Redis 设计与实现》的观点，即认为：Redis 的事务相当于是在 EXEC 执行时，才把客户端的事务命令打包传到服务器执行，这个过程中保证了不中断，即在执行过程中不会有其他客户端的命令插入其中，这其实就意味着保证了隔离性。
>
> WATCH 指令更多是用来保证涉及同一个 key 修改的事务不要因为执行顺序影响了结果，但是事务本身依然是隔离的。我个人认为，EXEC 执行之前的语句输入，并没有真正到达 Redis 服务端执行，所以不应该视为事务的隔离性被破坏。
>
> 具体另一种观点可以参考：[腾讯二面：Redis 事务支持 ACID 么？](https://cloud.tencent.com/developer/article/1892314)。其实这里关键就在于是否将客户端命令入队的过程视为事务已经在并发处理的过程中了，如果认为是，那就按照该文章的结论，认为 Redis 在 EXEC 之前是需要 WATCH 来保证隔离性的；如果否，则是按照《Redis 设计与实现》的结论，Redis 事务总是隔离性的。
>
> 这里大家更需要的关注的是 Redis 事务实现的本质，而不是死记答案。这样就算是面试官观点和自己相左，也可以认真和他探讨一下这个话题。

## 5.4 耐久性

事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。

因为 Redis 的事务不过是简单地用队列包裹起来了一组 Redis 命令，Redis 并没有为事务提供任何额外的持久化功能，所以 Redis 事务的耐久性由 Redis 所使用的持久化模式决定。

- 当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。

- 当服务器在 RDB 持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行 BGSAVE 命令，对数据库进行保存操作，并且异步执行的 BGSAVE 不能保证事务数据被第一时间保存到硬盘里面，因此 RDB 持久化下的事务也不具有耐久性。

- 当服务器运行在 AOF 持久化模式下，并且 `appendfsync` 选项的值为 `always` 时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有较高耐久性的。但其实还是可能丢失一个事件循环的数据，详情请参考 [AOF设置成为always时，数据绝对不会丢失吗？](https://segmentfault.com/a/1190000023154697)（下面附了其中一小段分析）

  > **always 模式下的 AOF 持久化**
  >
  > 其实我们每次执行客户端命令的时候操作并没有写到 AOF 文件中，只是写到了aof_buf 内存当中，当进行下一个事件循环的时候执行 beforeSleep 之时，才会去 fsync 到 disk 中。
  >
  > 从 Redis 的这种策略上我们也可以看出，Redis 和 MySQL 在数据持久化之间的区别，Redis 的数据持久化仅仅就是一个附带功能，并不是其主要功能，但是 MySQL 就不一样，MySQL 的在数据持久化方面就是刚需，最终目的就是让数据成功落盘，不会有任何的丢失和数据一致性问题，因此 MySQL （InnoDB 存储引擎）在做事务提交的时候会有两阶段提交、日志立即刷盘（当然这和sync_binlog 和 innodb_flush_log_at_trx_commit 配置有关）来确保数据的成功提交，不会丢失。

- 当服务器运行在 AOF 持久化模式下，并且 `appendfsync` 选项的值为 `everysec` 时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒内，这可能造成事务数据丢失，所以这种配置下的事务不具有耐久性。

- 当服务器运行在 AOF 持久化模式下，并且 `appendfsync` 选项的值为 `no` 时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。

> **no-appendsync-on-rewrite 配置选项对耐久性的影响**
>
> 配置选项 `no-appendsync-on-rewrite` 可以配合 `appendfsync` 选项为 `always` 或者 `everysec` 的 AOF 持久化模式使用。
>
> 当 `no-appendsync-on-rewrite` 选项处于打开状态时，在执行 BGSAVE 命令或者 BGREWRITEAOF 命令期间，服务器会暂时停止对 AOF 文件进行同步，从而尽可能地减少 I/O 阻塞。但是这样一来，关于“always 模式的 AOF 持久化可以保证事务的耐久性”这一结论将不再成立，因为在服务器停止对 AOF 文件进行同步期间，事务结果可能会因为停机而丢失。
>
> 因此，如果服务器打开了 `no-appendsync-on-rewrite` 选项，那么即使服务器运行在 `always` 模式的 AOF 持久化之下，事务也不具有耐久性。在默认配置下， `no-appendsync-on-rewrite` 处于关闭状态。

不论 Redis 在什么模式下运作，在一个事务的最后加上 SAVE 命令总可以保证事务的耐久性：

```sh
redis> MULTI
OK
redis> SET msg "hello"
QUEUED
redis> SAVE
QUEUED
redis> EXEC
1) OK
2) OK
```

不过因为这种做法效率太低，所以并不具有实用性。

# 参考文档

- 《Redis 深度历险：核心原理和应用实践》原理 5：同舟共济——事务
- 《Redis 开发与运维》3.4.1 事务
- 《Redis 设计与实现》第 19 章 事务
- AOF设置成为always时，数据绝对不会丢失吗？https://segmentfault.com/a/1190000023154697